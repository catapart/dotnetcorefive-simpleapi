<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="description" content="A simple tester app for the simple api functionality that cannot be tested with the OpenAPI visual schema">
    <meta property="og:title" content="API Tester" />
    <meta property="og:url" content="" />
    <meta property="og:description" content="A simple tester app for the simple api functionality that cannot be tested with the OpenAPI visual schema" />
    <link rel="stylesheet" href="main.css">
    <title>API Tester</title>
    <script defer>
        const apiDomain = new URL(window.location).host;

        const socketMessageTypeMap =
            [
                'Unknown', // error checking
                'Greeting', // sending the initial session token and host token
                'Introduction', // for gaining access to channels / providing user data like name/profile pic
                'Heartbeat', // keep-alive signals
                'Properties', // for properties like the participants list or the host id
                'StatusUpdates', // users joined/users left/users are typing/users are asleep/etc
                'Notifications', // relationship added/username tagged/ etc
                'Reaction', // reaction to a message
                'Text', // Text message
                'FormattedText', // Text message that should be handled with special cases
                'Url', // images/videos/audio/media/files anything linked via url
                'ByteArray' // binary data
            ];
        class WebsocketSession {

            get isHost() {
                let tokenId = this.token?.PeerId;
                let hostId = this.hostToken?.PeerId;
                if (tokenId == null || hostId == null || hostId != tokenId) {
                    return false;
                }
                return true;
            }

            constructor(type, unitTotal) {

                this.domain = new URL(window.location).host;

                this._sessionType = type || 'messaging';
                this._sessionType = this._sessionType.toLowerCase();
                this.unitTotal = unitTotal || -1;

                this.socket = null;
                this.sessionKey = null;
                this.token = null;
                this.hostToken = null;
                this.peerTokens = {};

                // easy event forwarding
                let node = document.createTextNode(null);
                this.addEventListener = node.addEventListener.bind(node);
                this.removeEventListener = node.removeEventListener.bind(node);
                this.dispatchEvent = node.dispatchEvent.bind(node);
            }

            async host(displayName, iconUrl, handlers) {


                let response = await fetch(`https://${this.domain}/api/websocket/${this._sessionType}${(this.unitTotal > -1) ? '/' + this.unitTotal : ''}`);
                let sessionKey = await response.text();
                console.log("Established new websocket session: ", sessionKey);
                let url = `wss://${this.domain}/${this._sessionType}/${sessionKey}`;

                return this.connect(url, displayName, iconUrl, handlers);
            }
            async join(sessionKey, displayName, iconUrl, handlers) {
                let url = `wss://${this.domain}/${this._sessionType}/${sessionKey}`;
                return this.connect(url, displayName, iconUrl, handlers);
            }

            async connect(url, displayName, iconUrl, handlers) {

                this.displayName = displayName;
                this.iconUrl = iconUrl || '';

                return new Promise(async (resolve, reject) => {
                    handlers = handlers || {};
                    handlers.onOpen = handlers.onOpen || this.websocket_onOpen.bind(this);
                    handlers.onMessage = handlers.onMessage || this.websocket_onMessage.bind(this);
                    handlers.onClose = handlers.onClose || this.websocket_onClose.bind(this);
                    handlers.onError = handlers.onError || this.websocket_onError.bind(this);
                    try {
                        if (this.socket != null) {
                            this.close();
                        }

                        this.socket = new WebSocket(url);

                        this.__resolveConnect__ = resolve;
                        this.__rejectConnect__ = reject;

                        this.socket.onopen = handlers.onOpen;
                        this.socket.onmessage = handlers.onMessage;
                        this.socket.onclose = handlers.onClose;
                        this.socket.onerror = handlers.onError;

                        window.addEventListener('beforeunload', () => {
                            this.socket.onclose = function () { }; // disable onclose handler first
                            this.socket.close();
                        }, { once: true });

                    }
                    catch (ex) {
                        if (this.__resolveConnect__ != undefined) {
                            delete this.__resolveConnect__;
                        }
                        if (this.__rejectConnect__ != undefined) {
                            delete this.__rejectConnect__;
                        }
                        console.error(ex);
                        reject();
                    }
                })
            }
            async send(message) {
                this.socket.send(message);
            }
            async close() {
                this.socket.close();
            }

            //handlers
            async websocket_onOpen(event) {
                console.log("[Websocket] Connection established");
            }
            async websocket_onMessage(event) {
                if (event.data instanceof ArrayBuffer) {
                    let senderArray = event.data.slice(0, 36);
                    let dataArray = event.data.slice(36);

                    let sender = new TextDecoder().decode(senderArray);

                    let binaryEvent = new CustomEvent('binary', { detail: { sender: sender, data: dataArray } });
                    this.dispatchEvent(binaryEvent);
                    return;
                }

                console.log(`[Websocket] Data received from server: ${event.data}`);


                // if it's not binary data, it should be JSON
                let data = JSON.parse(event.data);

                // delegate event to specialized functions
                // dispatch event if it's unrelated to the websocket session (messages/notifications/etc)
                switch (socketMessageTypeMap[data.MessageType]) {
                    case 'Greeting':
                        console.log('[Websocket] Greeting received.');
                        let greetingValue = JSON.parse(data.Message);
                        this.initSession(greetingValue);
                        let greetingEvent = new CustomEvent('greeting', { detail: greetingValue });
                        this.dispatchEvent(greetingEvent);
                        break;
                    case 'Introduction':
                        console.log('[Websocket] Introduction received.');
                        if (!this.isHost) {
                            console.error('Client should never receive "Introduction" Message Type.');
                        }
                        let introductionValue = JSON.parse(data.Message);
                        this.evaluateAccess(introductionValue);
                        break;
                    case 'Heartbeat':
                        console.log('[Websocket] Heartbeat received.');
                        // don't usually dispatch heartbeats, but I'm not utilizing them, either.
                        break;
                    case 'Properties':
                        console.log('[Websocket] Properties received.');
                        let propertiesValue = JSON.parse(data.Message);
                        let propertiesEvent = new CustomEvent('properties', { detail: propertiesValue });
                        this.dispatchEvent(propertiesEvent);
                        break;
                    case 'StatusUpdates':
                        console.log('[Websocket] Status Updates received.');
                        let statusUpdatesValue = JSON.parse(data.Message);
                        let updates = this.filterUpdates(statusUpdatesValue);
                        if (updates.accessUpdate != null) {
                            this.accessSession(updates.accessUpdate);
                        }
                        if (updates.connectionUpdates.length > 0) {
                            this.updatePeerStatus(updates.connectionUpdates);
                            let peersEvent = new CustomEvent('peers', { detail: updates.connectionUpdates });
                            this.dispatchEvent(peersEvent);
                        }
                        if (updates.otherUpdates.length > 0) {
                            let statusUpdatesEvent = new CustomEvent('statusupdates', { detail: updates.otherUpdates });
                            this.dispatchEvent(statusUpdatesEvent);
                        }
                        break;
                    case 'Notifications':
                        console.log('[Websocket] Notifications received.');
                        let notificationsEvent = new CustomEvent('notifications', { detail: otherUpdates });
                        this.dispatchEvent(notificationsEvent);
                        break;
                    case 'Reaction':
                        console.log('[Websocket] Reaction received.');
                        let reactionEvent = new CustomEvent('reaction', { detail: data });
                        this.dispatchEvent(reactionEvent);
                        break;
                    case 'Text':
                    case 'FormattedText':
                    case 'Url':
                    case 'ByteArray':
                        console.log('[Websocket] Message received.');
                        let messageEvent = new CustomEvent('message', { detail: data });
                        this.dispatchEvent(messageEvent);
                        break;
                    case 'Unknown':
                    default:
                        console.error("[Websocket] Unknown Message Type: " + data.MessageType);
                        return;
                }
            }
            async websocket_onClose(event) {

                if (event.wasClean) {
                    console.log(`[Websocket] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
                } else {
                    // e.g. server process killed or network down
                    // event.code is usually 1006 in this case
                    console.log('[Websocket] Connection died');
                }
                this.socket = null;
                let messageEvent = new CustomEvent('close');
                this.dispatchEvent(messageEvent);
            }
            async websocket_onError(event) {
                console.error(`[Websocket] Error: ${event}`);
                let messageEvent = new CustomEvent('error', { detail: event });
                this.dispatchEvent(messageEvent);
            }


            //functionality
            initSession(greeting) {

                this.sessionKey = greeting.SessionKey;
                this.token = greeting.Token;
                this.hostToken = greeting.HostToken;

                if (this._sessionType == 'messaging') {
                    this.updatePeers(greeting.Peers);

                    this.makeIntroduction();
                }
                else if (this._sessionType == 'progress') {
                    try {
                        this.__resolveConnect__();
                    }
                    catch (error) {
                        this.__rejectConnect__({ error: error });
                    }
                    finally {
                        if (this.__resolveConnect__ != undefined) {
                            delete this.__resolveConnect__;
                        }
                        if (this.__rejectConnect__ != undefined) {
                            delete this.__rejectConnect__;
                        }
                    }
                }

            }
            makeIntroduction() {

                let displayName = this.displayName || this.token.PeerId;
                this.token.DisplayName = displayName;
                this.token.IconUrl = '';

                console.log("Sending Introduction: ", this.token);
                let message = JSON.stringify(this.token);
                this.socket.send(JSON.stringify({ Type: 2, SenderId: this.token.PeerId, Message: message, Recipients: [this.hostToken.PeerId] }));
            }
            accessSession(accessUpdate) {
                try {
                    if (accessUpdate.Status == 'accessdenied') {
                        throw new Error('Access Denied');
                    }

                    let token = accessUpdate.Peers[0];
                    this.token = token;
                    if (this.token.PeerId == this.hostToken.PeerId) {
                        this.hostToken = token;
                    }
                    this.peerTokens[token.PeerId] = token;

                    // update all other peers in the chat that you have joined
                    let update = { Status: 'connect', Peers: [token] };
                    let message = JSON.stringify([update]);
                    console.log("Sending Connection to existing peers: ", message);
                    this.socket.send(JSON.stringify({ Type: 5, SenderId: this.token.PeerId, Message: message }));

                    this.__resolveConnect__(accessUpdate);
                }
                catch (error) {
                    this.__rejectConnect__({ error: error, update: accessUpdate });
                }
                finally {
                    if (this.__resolveConnect__ != undefined) {
                        delete this.__resolveConnect__;
                    }
                    if (this.__rejectConnect__ != undefined) {
                        delete this.__rejectConnect__;
                    }
                }
            }
            evaluateAccess(peer) {
                if (peer == null) {
                    console.error("Cannot evaluate access of null peer.");
                    return;
                }

                console.log("Evaluating access: ", peer);
                let access = false;
                access = true; // [enhancement]: Any host evaluation of client access

                let update = { Status: 'accessdenied', Peers: [peer] };
                if (access == true) {
                    console.log("Access Granted for", peer);
                    update.Status = 'accessgranted';
                }
                let message = JSON.stringify([update]);
                console.log("Sending Access: ", message);
                this.socket.send(JSON.stringify({ Type: 5, SenderId: this.token.PeerId, Message: message, Recipients: [peer.PeerId] }));
            }


            filterUpdates(statusUpdates) {
                let accessUpdate = null;
                let connectionUpdates = [];
                let otherUpdates = [];
                for (let i = 0; i < statusUpdates.length; i++) {
                    let statusUpdate = statusUpdates[i];
                    let status = statusUpdate.Status.toLowerCase();
                    if (status == 'accessgranted' || status == 'accessdenied') {
                        accessUpdate = statusUpdate;
                        continue;
                    }
                    if (status.indexOf('connect') == -1) {
                        otherUpdates.push(statusUpdate);
                        continue;
                    }
                    else {
                        connectionUpdates.push(statusUpdate);
                    }
                }

                return { accessUpdate, connectionUpdates, otherUpdates };
            }

            updatePeerStatus(updates) {
                for (let i = 0; i < updates.length; i++) {
                    let update = updates[i];
                    if (update.Status == 'disconnect') {
                        this.removePeers(update.Peers);
                        continue;
                    }
                    this.updatePeers(update.Peers);
                }
            }
            updatePeers(peers) {
                if (peers == null) {
                    return;
                }
                for (let i = 0; i < peers.length; i++) {
                    let peer = peers[i];
                    this.updatePeer(peer);
                }
            }
            updatePeer(peer) {

                if (peer.PeerId == this.token.PeerId) {
                    this.token = peer;
                }
                if (peer.PeerId == this.hostToken.PeerId) {
                    this.hostToken = peer;
                }

                this.peerTokens[peer.PeerId] = peer;
            }
            removePeers(peers) {
                if (peers == null) {
                    return;
                }
                for (let i = 0; i < peers.length; i++) {
                    let peer = peers[i];
                    this.removePeer(peer);
                }
            }
            removePeer(peer) {
                delete this.peerTokens[peer.PeerId];
            }
        }
    </script>
</head>

<body>
    <main>
        <header class="full-width">
            <div class="inset">
                <div>
                    <h1><img class="icon logo" src="" />API Tester</h1>
                    <h2 class="version"></h2>
                </div>
                <h3>This page is for testing non-REST functionality, including file streaming, websocket, and WebRTC sessions.</h3>
                <h3>For testing any standard REST endpoints, please use the OpenAPI route (this can be set as the default in launchsettings.json)</h3>
                <p><small><em>Icons provided by <a href="https://iconmonstr.com/" title="Link to Icon Monster">iconmonstr</a></em></small></p>
            </div>
        </header>

        <div class="content full-width">

            <div class="card chat">
                <header>
                    <h4>Text Chat</h4>
                </header>
                <div class="content">
                    <div class="chatroom">
                        <header>
                            <div class="title">Host's Chatroom</div>
                            <button class="exit" type="button" disabled>
                                <svg class="icon" width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd"><path d="M11 21h8v-2l1-1v4h-9v2l-10-3v-18l10-3v2h9v5l-1-1v-3h-8v18zm10.053-9l-3.293-3.293.707-.707 4.5 4.5-4.5 4.5-.707-.707 3.293-3.293h-9.053v-1h9.053z" /></svg>
                                <span class="title">Exit Chat</span>
                            </button>
                        </header>
                        <details class="peers">
                            <summary><span class="first-peer">Host</span><span class="description">and <span class="modified-count">1</span> others...</span></summary>
                            <dl>
                                <dt>Host</dt>
                                <dt>Test User</dt>
                            </dl>
                        </details>
                        <div class="display">
                            <ul id="chat-messages">
                                <li class="no-session">No session has been started.</li>
                                <li class="status">Test User has joined the chat</li>
                                <li class="message self">
                                    <div class="body">
                                        <div class="content">
                                            Hola Mundo!
                                        </div>
                                        <footer>
                                            <span class="time">10:31</span>
                                            <span class="month">1</span>/
                                            <span class="day">1</span>/
                                            <span class="year">2021</span>
                                        </footer>
                                    </div>
                                </li>
                                <li class="message">
                                    <span class="user">
                                        <span class="image-container">
                                            <svg class="icon user" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2c2.757 0 5 2.243 5 5.001 0 2.756-2.243 5-5 5s-5-2.244-5-5c0-2.758 2.243-5.001 5-5.001zm0-2c-3.866 0-7 3.134-7 7.001 0 3.865 3.134 7 7 7s7-3.135 7-7c0-3.867-3.134-7.001-7-7.001zm6.369 13.353c-.497.498-1.057.931-1.658 1.302 2.872 1.874 4.378 5.083 4.972 7.346h-19.387c.572-2.29 2.058-5.503 4.973-7.358-.603-.374-1.162-.811-1.658-1.312-4.258 3.072-5.611 8.506-5.611 10.669h24c0-2.142-1.44-7.557-5.631-10.647z" /></svg>
                                        </span>
                                        <span class="name">Test User</span>
                                    </span>
                                    <div class="body">
                                        <header>
                                        </header>
                                        <div class="content">
                                            Hi! I hope this message finds you well!
                                        </div>
                                        <footer>
                                            <span class="time">10:33</span>
                                            <span class="month">1</span>/
                                            <span class="day">1</span>/
                                            <span class="year">2021</span>
                                        </footer>
                                    </div>
                                </li>
                            </ul>
                        </div>
                        <form id="text-chat-message">
                            <input class="value" name="message" type="text" placeholder="Send a message..." autocomplete="off" />
                            <button class="submit" type="submit" title="Send message">
                                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M24 0l-6 22-8.129-7.239 7.802-8.234-10.458 7.227-7.215-1.754 24-12zm-15 16.668v7.332l3.258-4.431-3.258-2.901z" /></svg>
                                <span class="label">Send</span>
                            </button>
                        </form>
                    </div>
                    <div class="setup">
                        <span class="display host">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M3.449 15.19c-.92-1.513-1.449-3.289-1.449-5.189 0-5.523 4.477-10.001 10-10.001s10 4.478 10 10.001c0 1.9-.529 3.676-1.451 5.189.513-1.156.797-2.434.797-3.78 0-5.163-4.184-9.347-9.346-9.347s-9.346 4.185-9.346 9.347c0 1.345.284 2.624.795 3.78zm3.108-3.78c0-3.006 2.438-5.442 5.443-5.442s5.443 2.437 5.443 5.443c0 .696-.133 1.362-.371 1.975.648-.969 1.025-2.132 1.025-3.384 0-3.368-2.73-6.099-6.098-6.099s-6.098 2.73-6.098 6.099c0 1.252.377 2.416 1.025 3.384-.237-.613-.369-1.279-.369-1.976zm6.443 2.59c1.162-.414 2-1.512 2-2.816 0-1.657-1.344-3-3-3s-3 1.343-3 3c0 1.304.838 2.403 2 2.816l-5 10h2.236c.713-1.426 2.17-2.326 3.764-2.326s3.051.9 3.764 2.326h2.236l-5-10zm-2.764 6l1.764-3.528 1.764 3.528h-3.528z" /></svg>
                            <span class="description">Host</span>
                        </span>
                        <div class="display join">
                            <svg class="icon" width="24" height="24" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill-rule="evenodd" clip-rule="evenodd"><path d="M20 15c0 .552-.448 1-1 1s-1-.448-1-1 .448-1 1-1 1 .448 1 1m-3 0c0 .552-.448 1-1 1s-1-.448-1-1 .448-1 1-1 1 .448 1 1m-3 0c0 .552-.448 1-1 1s-1-.448-1-1 .448-1 1-1 1 .448 1 1m5.415 4.946c-1 .256-1.989.482-3.324.482-3.465 0-7.091-2.065-7.091-5.423 0-3.128 3.14-5.672 7-5.672 3.844 0 7 2.542 7 5.672 0 1.591-.646 2.527-1.481 3.527l.839 2.686-2.943-1.272zm-13.373-3.375l-4.389 1.896 1.256-4.012c-1.121-1.341-1.909-2.665-1.909-4.699 0-4.277 4.262-7.756 9.5-7.756 5.018 0 9.128 3.194 9.467 7.222-1.19-.566-2.551-.889-3.967-.889-4.199 0-8 2.797-8 6.672 0 .712.147 1.4.411 2.049-.953-.126-1.546-.272-2.369-.483m17.958-1.566c0-2.172-1.199-4.015-3.002-5.21l.002-.039c0-5.086-4.988-8.756-10.5-8.756-5.546 0-10.5 3.698-10.5 8.756 0 1.794.646 3.556 1.791 4.922l-1.744 5.572 6.078-2.625c.982.253 1.932.407 2.85.489 1.317 1.953 3.876 3.314 7.116 3.314 1.019 0 2.105-.135 3.242-.428l4.631 2-1.328-4.245c.871-1.042 1.364-2.384 1.364-3.75" /></svg>
                            <span class="description">Join</span>
                            <small class="label">Session Key</small>
                            <form id="text-session-key-form">
                                <input class="session-key" type="text" placeholder="xxxxx" title="Session Key" />
                            </form>
                        </div>
                        <div class="choice host">
                            <div class="control">
                                <small class="label">Display Name</small>
                                <form id="text-host-form">
                                    <input class="display-name" type="text" title="Display Name" value="Host" />
                                    <button class="action" type="submit">Host Chat</button>
                                </form>
                            </div>
                            <span class="message">This is an error</span>
                        </div>
                        <div class="choice join">
                            <div class="control">
                                <small class="label">Display Name</small>
                                <form id="text-join-form">
                                    <input class="display-name" type="text" title="Display Name" value="Guest" />
                                    <button class="action" type="submit">Join Chat</button>
                                </form>
                            </div>
                            <span class="message">This is a really long error that should wrap to the next line and still be legible in all circumstances</span>
                        </div>
                    </div>
                </div>
                <script defer type="module">
                    document.addEventListener('DOMContentLoaded', Init);

                    async function Init() {
                        // establish a well-known variable
                        // to hold the websocket session
                        let chatSession = null;

                        // define well-known html elements
                        const $chatroom = document.querySelector('.card.chat .chatroom');
                        $chatroom.$title = $chatroom.querySelector('header > .title');

                        const $textExitButton = $chatroom.querySelector('header > .exit');

                        const $peers = $chatroom.querySelector('.peers');
                        $peers.$firstPeer = $peers.querySelector('.first-peer');
                        $peers.$modifiedCount = $peers.querySelector('.modified-count');
                        $peers.$chatPeers = $peers.querySelector('dl');

                        const $chatMessages = document.getElementById('chat-messages');
                        $chatMessages.$noSession = $chatMessages.querySelector('.no-session');

                        const $textChatMessageForm = document.getElementById('text-chat-message');
                        $textChatMessageForm.$value = $textChatMessageForm.querySelector('input');
                        $textChatMessageForm.$submit = $textChatMessageForm.querySelector('.submit');

                        const $chatSetup = document.querySelector('.card.chat .setup');

                        const $textHostDisplayName = $chatSetup.querySelector('.choice.host .display-name');
                        const $textHostForm = document.getElementById('text-host-form');
                        const $textHostButton = $chatSetup.querySelector('.choice.host .action');
                        const $textHostErrorMessage = $chatSetup.querySelector('.choice.host .message');

                        const $textSessionKeyForm = document.getElementById('text-session-key-form');
                        const $textGuestSessionKey = $chatSetup.querySelector('.display.join .session-key');
                        const $textGuestDisplayName = $chatSetup.querySelector('.choice.join .display-name');
                        const $textJoinForm = document.getElementById('text-join-form');
                        const $textJoinButton = $chatSetup.querySelector('.choice.join .action');
                        const $textJoinErrorMessage = $chatSetup.querySelector('.choice.join .message');

                        let _$messageDisplay = null;

                        // add functionality
                        $textExitButton.addEventListener('click', textExitChat_onClick);
                        $textHostForm.addEventListener('submit', textHostChat_onSubmit);
                        $textSessionKeyForm.addEventListener('submit', textJoinChat_onSubmit);
                        $textJoinForm.addEventListener('submit', textJoinChat_onSubmit);
                        $textChatMessageForm.addEventListener('submit', textChatMessageForm_onSubmit);

                        // prepare page for new chat session
                        resetChat();

                        // handlers
                        async function textHostChat_onSubmit(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            try {
                                if (chatSession != null) {
                                    console.error('Session is already active. End the session before starting a new one.');
                                    return;
                                }

                                _$messageDisplay = $textHostErrorMessage;

                                resetChat();

                                chatSession = createChatSession();
                                await chatSession.host($textHostDisplayName.value);

                                prepareChat();

                                $textExitButton.removeAttribute('disabled');
                                $textHostButton.setAttribute('disabled', 'disabled');
                                $textJoinButton.setAttribute('disabled', 'disabled');

                                $chatroom.classList.add('in-session');
                            }
                            catch (exception) {
                                resetChat();
                                showChatError($textHostErrorMessage, exception);
                            }
                            finally {
                                _$messageDisplay = null;
                                return false;
                            }
                        }

                        async function textJoinChat_onSubmit(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            try {
                                if (chatSession != null) {
                                    console.error('Session is already active. End the session before starting a new one.');
                                    return;
                                }
                                _$messageDisplay = $textJoinErrorMessage;

                                resetChat();

                                chatSession = createChatSession();
                                await chatSession.join($textGuestSessionKey.value, $textGuestDisplayName.value);

                                prepareChat();

                                $textExitButton.removeAttribute('disabled');
                                $textJoinButton.setAttribute('disabled', 'disabled');
                                $textHostButton.setAttribute('disabled', 'disabled');

                                $chatroom.classList.add('in-session');
                            }
                            catch (exception) {
                                resetChat();
                                showChatError($textJoinErrorMessage, exception);
                            }
                            finally {
                                _$messageDisplay = null;
                                return false;
                            }
                        }

                        async function textExitChat_onClick(event) {
                            if (chatSession == null) {
                                return;
                            }

                            chatSession.ending = true;
                            await chatSession.close();

                            $textHostButton.removeAttribute('disabled');
                            $textJoinButton.removeAttribute('disabled');
                            $textExitButton.setAttribute('disabled', 'disabled');
                        }

                        async function textChatMessageForm_onSubmit(event) {
                            event.preventDefault();
                            event.stopPropagation();

                            if (chatSession == null) {
                                console.error("No session has been started.");
                                return false;
                            }

                            console.log("Sending to server");
                            addChatMessage({ SenderId: chatSession.token.PeerId, Message: $textChatMessageForm.$value.value });
                            chatSession.send(JSON.stringify({ Message: $textChatMessageForm.$value.value }));

                            $textChatMessageForm.$value.value = '';
                            return false;
                        }

                        function chatSession_OnPeers(event) {
                            updateChatPeers();

                            // show messages
                            let updates = event.detail;
                            for (let i = 0; i < updates.length; i++) {
                                let update = updates[i];
                                for (let j = 0; j < update.Peers.length; j++) {
                                    let peer = update.Peers[j];
                                    let displayName = (peer.DisplayName == '') ? `[${peer.PeerId}]` : peer.DisplayName;
                                    let isHost = peer.PeerId == chatSession.hostToken.PeerId;
                                    if (update.Status == 'connect' && isHost == false) {
                                        let content = `<div>${displayName} has joined the chat.</div>`;
                                        let $joinMessage = addChatStatus(content);
                                    }
                                    else if (update.Status == 'disconnect') {
                                        let action = (isHost == true) ? 'ended' : 'left';
                                        let content = `<div>${displayName} has ${action} the chat.</div>`;
                                        let $leaveMessage = addChatStatus(content);
                                    }
                                }
                            }
                        }
                        function chatSession_OnMessage(event) {
                            addChatMessage(event.detail);
                        }
                        function chatSession_OnClose(event) {
                            if (chatSession.ending == true) {
                                let action = (chatSession.token.PeerId == chatSession.hostToken.PeerId) ? 'ended' : 'left';
                                addChatStatus(`[You have ${action} the chat session.]`);
                                setSessionState(false);
                            }
                            else {
                                addChatStatus('[The chat session has been ended.]');
                                setSessionState(false);
                            }
                            chatSession = null;
                        }
                        function chatSession_OnError(event) {
                            if (_$messageDisplay != null) {
                                _$messageDisplay.textContent = "An error occurred while trying to connect to the session. If you are trying to join, please check the session key and try again."
                            }
                            console.log(event);
                        }

                        // functionality
                        function resetChat() {
                            setSessionState(false);
                            clearChatHistory();
                            clearErrors();
                        }
                        function prepareChat() {
                            setSessionState(true);

                            let introMessage = '';
                            let hostName = (chatSession.hostToken.DisplayName || 'Host');
                            if (chatSession.token.PeerId == chatSession.hostToken.PeerId) {
                                introMessage = `You (${hostName}) have started a text chat session.`;
                            }
                            else {
                                introMessage = `You have joined ${hostName}'s chat.`;
                            }
                            $chatroom.$title.textContent = hostName + '\'s text chat';
                            clearChatHistory();
                            updateChatPeers();

                            addChatStatus(introMessage);
                            addSessionKeyMessage(chatSession.sessionKey);
                        }

                        function setSessionState(inSession) {
                            if (inSession == true) {
                                $chatroom.classList.add('in-session');
                                $textChatMessageForm.$submit.removeAttribute('disabled');
                            }
                            else {
                                $chatroom.classList.remove('in-session');
                                $chatroom.$title.textContent = '';
                                clearChatParticipants();
                                $textHostButton.removeAttribute('disabled');
                                $textJoinButton.removeAttribute('disabled');
                                $textChatMessageForm.$submit.setAttribute('disabled', 'disabled');
                            }
                        }

                        function createChatSession() {
                            let session = new WebsocketSession();
                            session.addEventListener('peers', chatSession_OnPeers);
                            session.addEventListener('message', chatSession_OnMessage);
                            session.addEventListener('close', chatSession_OnClose);
                            session.addEventListener('error', chatSession_OnError);
                            return session;
                        }

                        function clearErrors() {
                            $textHostErrorMessage.textContent = '';
                            $textJoinErrorMessage.textContent = '';
                        }
                        function clearChatHistory() {
                            while ($chatMessages.lastChild) {
                                $chatMessages.lastChild.remove();
                            }

                            if (chatSession == null) {
                                $chatMessages.appendChild($chatMessages.$noSession);
                            }
                        }
                        function clearChatParticipants() {
                            while ($peers.$chatPeers.lastChild) {
                                $peers.$chatPeers.lastChild.remove();
                            }

                            $peers.classList.remove('others');
                            $peers.$firstPeer.textContent = '';
                            $peers.$modifiedCount.textContent = '';
                        }
                        function updateChatPeers() {
                            clearChatParticipants();

                            for (let property in chatSession.peerTokens) {

                                let peer = chatSession.peerTokens[property];
                                let displayName = (peer.DisplayName == '') ? `[${peer.PeerId}]` : peer.DisplayName;
                                let $peer = document.createElement('dt');
                                $peer.classList.add('peer');
                                if (peer == chatSession.hostToken) {
                                    $peer.classList.add('host');
                                }
                                if (peer == chatSession.token) {
                                    $peer.classList.add('self');
                                }
                                $peer.textContent = displayName;
                                $peers.$chatPeers.appendChild($peer);
                            }

                            let hostName = (chatSession.hostToken.DisplayName || 'Host');
                            let peerTokenCount = Object.keys(chatSession.peerTokens)?.length
                            $peers.$firstPeer.textContent = hostName;
                            $peers.$modifiedCount.textContent = peerTokenCount - 1;
                            if (peerTokenCount > 1) {
                                $peers.classList.add('others');
                            }
                        }
                        function addChatStatus(statusMessage) {
                            let $message = document.createElement('li');
                            $message.classList.add('status');
                            $message.innerHTML = statusMessage;

                            $chatMessages.appendChild($message);
                            return $message;
                        }
                        function addSessionKeyMessage(sessionKey) {

                            let $message = document.createElement('li');
                            $message.classList.add('session-key');
                            $message.innerHTML = `<span class="description">Session Key:</span>
                                                            <input class="value" type="text" />
                                                            <button class="copy" type="button" title="Copy Session Key">Copy</button>`;

                            const $value = $message.querySelector('.value');
                            $value.value = sessionKey;
                            const $copyButton = $message.querySelector('.copy');
                            $copyButton.addEventListener('click', () => {

                                if (chatSession == null) {
                                    console.error('Cannot copy session key from session that has not been started.');
                                    return;
                                }
                                $value.select();
                                $value.setSelectionRange(0, 99999);
                                document.execCommand('copy');
                                addChatStatus('Copied the Session Key');
                            });

                            $chatMessages.appendChild($message);
                            return $message;
                        }
                        function addChatMessage(messageData) {
                            let $message = document.createElement('li');
                            $message.classList.add('message');

                            let content;
                            if (Object.prototype.toString.call(messageData) === '[object String]') {
                                content = `${messageData}`;
                            }
                            else {
                                let peer = (messageData.SenderId == chatSession.token.PeerId) ? chatSession.token : chatSession.peerTokens[messageData.SenderId];
                                if (peer == null) {
                                    console.error('Unknown Participant. Socket ID: ' + messageData.SenderId);
                                    return;
                                }
                                let currentDate = new Date();
                                let date = (((currentDate.getMonth() + 1) < 10) ? '0' + (currentDate.getMonth() + 1) : (currentDate.getMonth() + 1)) + '/' + ((currentDate.getDate() < 10) ? '0' + currentDate.getDate() : currentDate.getDate()) + '/' + currentDate.getFullYear();
                                let meridian = 'am';
                                let hours = currentDate.getHours();
                                if (hours > 12) {
                                    meridian = 'pm';
                                    hours = currentDate.getHours() - 12;
                                }
                                let time = (hours < 10 ? '0' + hours : hours) + ':' + currentDate.getMinutes() + ' ' + meridian;
                                let userContent = '';
                                if (peer != chatSession.token) {
                                    userContent = `<span class="user">
                                                                                                                                                                                <span class="image-container">
                                                                                                                                                                                    ${peer.IconUrl || `<svg class="icon user" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2c2.757 0 5 2.243 5 5.001 0 2.756-2.243 5-5 5s-5-2.244-5-5c0-2.758 2.243-5.001 5-5.001zm0-2c-3.866 0-7 3.134-7 7.001 0 3.865 3.134 7 7 7s7-3.135 7-7c0-3.867-3.134-7.001-7-7.001zm6.369 13.353c-.497.498-1.057.931-1.658 1.302 2.872 1.874 4.378 5.083 4.972 7.346h-19.387c.572-2.29 2.058-5.503 4.973-7.358-.603-.374-1.162-.811-1.658-1.312-4.258 3.072-5.611 8.506-5.611 10.669h24c0-2.142-1.44-7.557-5.631-10.647z" /></svg>`}
                                                                                                                                                                                </span>
                                                                                                                                                                                <span class="name">${peer.DisplayName || 'Unknown Guest'}</span>
                                                                                                                                                                            </span>
                                                                                                                                                                            `;
                                }
                                else {
                                    $message.classList.add('self');
                                }

                                content = `${userContent}<div class="body">
                                                                                                                                                                        <div class="content">
                                                                                                                                                                            ${messageData.Message}
                                                                                                                                                                        </div>
                                                                                                                                                                        <footer>
                                                                                                                                                                            <span class="date">${date}</span>
                                                                                                                                                                            <span class="time">${time}</span>
                                                                                                                                                                        </footer>
                                                                                                                                                                    </div>`;
                            }

                            $message.innerHTML = content;

                            $chatMessages.appendChild($message);

                            $chatMessages.scrollTop = $chatMessages.scrollHeight - $chatMessages.getBoundingClientRect().height;
                            return $message;
                        }
                        function showChatError($target, error) {
                            console.error(error);
                            $target.textContent = 'An error has occurred. Please see the console for more details.';
                        }
                    }
                </script>
            </div>

            <div class="card file-upload">
                <header>
                    <h4>File Upload (with progress)</h4>
                </header>
                <div class="content">
                    <div class="display">
                        <svg class="icon upload" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M8 10h-5l9-10 9 10h-5v10h-8v-10zm11 9v3h-14v-3h-2v5h18v-5h-2z" /></svg>
                        <span class="title">File Upload</span>
                        <span class="description">Upload a file to the webserver and view it's progress in real time with websockets.</span>
                    </div>
                    <form id="file-upload-form" enctype="multipart/form-data" method="post">
                        <label class="field-group file">
                            <span class="label">Select a file...</span>
                            <span class="icon-container">
                                <svg class="icon file" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M13.744 8s1.522-8-3.335-8h-8.409v24h20v-13c0-3.419-5.247-3.745-8.256-3zm4.256 11h-12v-1h12v1zm0-3h-12v-1h12v1zm0-3h-12v-1h12v1zm-3.432-12.925c2.202 1.174 5.938 4.883 7.432 6.881-1.286-.9-4.044-1.657-6.091-1.179.222-1.468-.185-4.534-1.341-5.702z" /></svg>
                            </span>
                            <span class="value-container">
                                <!-- [NOTE]: for dotnetcore to pick this up as the body of a multipart
                             file, the input MUST have a "name" attribute. Note that we don't reference
                             this attribute or its value anywhere else. It just has to have one.
                        -->
                                <input class="value" name="target" type="file" id="file-upload-input" accept="*" required />
                            </span>
                            <button class="clear" title="Clear selected file" type="button">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6 16.538l-4.592-4.548 4.546-4.587-1.416-1.403-4.545 4.589-4.588-4.543-1.405 1.405 4.593 4.552-4.547 4.592 1.405 1.405 4.555-4.596 4.591 4.55 1.403-1.416z" /></svg>
                            </button>
                        </label>
                        <button id="upload-file" type="submit" disabled>Upload</button>
                        <span class="divider"></span>
                        <span class="progress-controls">
                            <progress id="upload-progress" min="0" max="100" step="1" disabled></progress>
                            <button id="cancel-upload" type="button" title="Cancel Upload" disabled>
                                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6 16.538l-4.592-4.548 4.546-4.587-1.416-1.403-4.545 4.589-4.588-4.543-1.405 1.405 4.593 4.552-4.547 4.592 1.405 1.405 4.555-4.596 4.591 4.55 1.403-1.416z" /></svg>
                                <span class="label">Cancel</span>
                            </button>
                        </span>
                        <span class="message">This is an error</span>
                    </form>
                </div>
                <script defer type="module">
                    document.addEventListener('DOMContentLoaded', Init);

                    async function Init() {
                        // establish a well-known variable
                        // to hold the websocket session
                        let fileUploadSession = null;
                        let fileUploadCancelled = false;

                        // define well-known html elements
                        const $fileUploadForm = document.getElementById('file-upload-form');
                        const $fileUploadInput = document.getElementById('file-upload-input');
                        const $fileUploadClearButton = $fileUploadForm.querySelector('button.clear');
                        const $fileUploadSubmitButton = document.getElementById('upload-file');
                        const $fileUploadProgress = document.getElementById('upload-progress');
                        const $fileUploadCancelButton = document.getElementById('cancel-upload');
                        const $fileUploadMessage = $fileUploadForm.querySelector('.message');

                        // add functionality
                        $fileUploadForm.addEventListener('submit', fileUploadForm_onSubmit);
                        $fileUploadInput.addEventListener('input', fileUploadInput_onInput);
                        $fileUploadClearButton.addEventListener('click', fileUploadClearButton_onClick);
                        $fileUploadCancelButton.addEventListener('click', fileUploadCancelButton_onClick);

                        // prepare page
                        resetFileUploadForm();

                        // handlers
                        async function fileUploadForm_onSubmit(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            try {
                                resetFileUploadFormStatus();

                                setFileUploadMessage('Initializing...');

                                fileUploadSession = createFileUploadSession();
                                await fileUploadSession.host('Progress');
                                console.log("Established new websocket session: ", fileUploadSession.sessionKey);
                                setFileUploadMessage("Established new websocket session.");

                                setFileUploadMessage('Submitting Form Data...');
                                $fileUploadCancelButton.removeAttribute('disabled');
                                let options =
                                {
                                    method: "POST",
                                    body: new FormData($fileUploadForm)
                                };
                                const response = await fetch(`https://${apiDomain}/api/streaming/progress/${fileUploadSession.sessionKey}`, options);
                                if (response.ok == true && fileUploadCancelled == false) {
                                    const fileData = await response.json();
                                    console.log(fileData);

                                    window.open(`https://${apiDomain}/assets/${fileData.filePath}`);
                                }
                                else if (fileUploadCancelled == true) {
                                    resetFileUploadFormStatus();
                                    setFileUploadMessage('Upload Cancelled');
                                }
                            }
                            catch (exception) {
                                console.error(exception);
                                setFileUploadMessage("An error occured, while establishing a new websocket session. See the console log for more details.");
                            }
                            finally {
                                return false;
                            }

                        }
                        function fileUploadInput_onInput(event) {
                            if (event.currentTarget.value != null && event.currentTarget.value.trim() != "") {
                                $fileUploadSubmitButton.removeAttribute('disabled');
                                $fileUploadProgress.removeAttribute('disabled');
                            }
                            else {
                                $fileUploadSubmitButton.setAttribute('disabled', 'disabled');
                                $fileUploadProgress.setAttribute('disabled', 'disabled');
                            }
                        }
                        function fileUploadClearButton_onClick(event) {
                            resetFileUploadForm();
                        }
                        function fileUploadCancelButton_onClick(event) {
                            cancelFileUpload();
                        }

                        function fileUpload_OnStatusUpdates(event) {
                            const updates = event.detail;
                            for (let i = 0; i < updates.length; i++) {
                                updateFileUploadProgress(updates[i])
                            }
                        }
                        function fileUpload_OnError(event) {
                            console.error(error);
                            setFileUploadMessage("An error occurred while creating the progress session", true);
                        }
                        function fileUpload_OnClose(event) {
                            fileUploadSession = null;
                            $fileUploadCancelButton.setAttribute('disabled', true);
                            if (!$fileUploadMessage.classList.contains('error')) {
                                setFileUploadMessage('Upload complete.');
                            }
                        }

                        // functionality
                        function resetFileUploadForm() {
                            $fileUploadInput.value = null;
                            fileUploadInput_onInput({ currentTarget: $fileUploadInput });
                            resetFileUploadFormStatus();
                        }
                        function resetFileUploadFormStatus() {
                            fileUploadCancelled = false;
                            $fileUploadMessage.textContent = "";
                            $fileUploadMessage.title = "";
                            $fileUploadMessage.classList.remove('error');
                            $fileUploadProgress.title = "";
                            $fileUploadProgress.value = 0;
                            $fileUploadCancelButton.setAttribute('disabled', true);
                        }

                        function createFileUploadSession() {

                            let totalBytes = $fileUploadInput.files[0].size;

                            let session = new WebsocketSession('progress', totalBytes);
                            session.addEventListener('statusupdates', fileUpload_OnStatusUpdates);
                            session.addEventListener('error', fileUpload_OnError);
                            session.addEventListener('close', fileUpload_OnClose);
                            return session;
                        }
                        function updateFileUploadProgress(update) {
                            if (update.Status != 'progress') {
                                return;
                            }

                            const progressPercent = (update.Progress.UnitsCompleted / update.Progress.UnitTotal) * 100;
                            const message = `Uploading: ${formatBytes(update.Progress.UnitsCompleted)} of ${formatBytes(update.Progress.UnitTotal)} (${parseInt(progressPercent)}%)`;
                            let isComplete = update.Progress.UnitsCompleted == update.Progress.UnitTotal;
                            let isError = false;
                            if (isComplete == true) {
                                if (update.Progress.UnitsCompleted == -1) {
                                    message = 'The uploaded file could not be opened by the server. Please check the file and try again.';
                                    isError = true;
                                }
                            }
                            setFileUploadMessage(message, isError);
                            $fileUploadProgress.value = progressPercent;

                            const titleText = `${update.Progress.UnitsCompleted} of ${update.Progress.UnitTotal} bytes`;
                            $fileUploadMessage.title = titleText;
                            $fileUploadProgress.title = titleText;

                            if (isComplete == true) {
                                fileUploadSession.close();
                            }
                        }
                        function formatBytes(bytes, decimals = 2) {
                            if (bytes === 0) return '0 Bytes';

                            const k = 1024;
                            const dm = decimals < 0 ? 0 : decimals;
                            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

                            const i = Math.floor(Math.log(bytes) / Math.log(k));

                            return parseFloat((bytes / Math.pow(k, i))).toFixed(dm) + ' ' + sizes[i];
                        }
                        function setFileUploadMessage(message, isError) {
                            $fileUploadMessage.textContent = message;
                            if (isError == true) {
                                $fileUploadMessage.classList.add('error');
                            }
                        }
                        function cancelFileUpload() {
                            if (fileUploadSession == null) {
                                return;
                            }

                            fileUploadCancelled = true;
                            fetch(`https://${apiDomain}/api/streaming/progress/${fileUploadSession.sessionKey}/cancel`);
                        }
                    }
                </script>
            </div>


            <div class="card video-chat">
                <header>
                    <h4>Video Chat</h4>
                </header>
                <div class="content">
                    <div class="chatroom">
                        <header>
                            <div class="title">Host's Chatroom</div>
                            <button class="exit" type="button" disabled>
                                <svg class="icon" width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd"><path d="M11 21h8v-2l1-1v4h-9v2l-10-3v-18l10-3v2h9v5l-1-1v-3h-8v18zm10.053-9l-3.293-3.293.707-.707 4.5 4.5-4.5 4.5-.707-.707 3.293-3.293h-9.053v-1h9.053z" /></svg>
                                <span class="title">Exit Chat</span>
                            </button>
                        </header>
                        <div class="display">
                            <div class="stage">
                                <video id="priority-video-stream" autoplay="autoplay" src="https://storage.coverr.co/videos/qo301lESiwxA01mnfLIEwtfHAGnxWzirQ6?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcHBJZCI6Ijg3NjdFMzIzRjlGQzEzN0E4QTAyIiwiaWF0IjoxNjExMTc4NjAxfQ.epzkpzjkQX6Az6r9TBJfnx0YAImP4rmvFGe55Koo63w"></video>
                                <ul id="video-streams">
                                    <li class="video-stream">
                                        <video autoplay="autoplay" src="https://storage.coverr.co/videos/qo301lESiwxA01mnfLIEwtfHAGnxWzirQ6?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcHBJZCI6Ijg3NjdFMzIzRjlGQzEzN0E4QTAyIiwiaWF0IjoxNjExMTc4NjAxfQ.epzkpzjkQX6Az6r9TBJfnx0YAImP4rmvFGe55Koo63w"></video>
                                        <button class="set-priority" type="button" data-peer-name="Host"></button>
                                    </li>
                                    <li class="video-stream">
                                        <video autoplay="autoplay" src="https://storage.coverr.co/videos/qo301lESiwxA01mnfLIEwtfHAGnxWzirQ6?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcHBJZCI6Ijg3NjdFMzIzRjlGQzEzN0E4QTAyIiwiaWF0IjoxNjExMTc4NjAxfQ.epzkpzjkQX6Az6r9TBJfnx0YAImP4rmvFGe55Koo63w"></video>
                                        <button class="set-priority" type="button" data-peer-name="Guest 1"></button>
                                    </li>
                                    <li class="video-stream">
                                        <video autoplay="autoplay" src="https://storage.coverr.co/videos/qo301lESiwxA01mnfLIEwtfHAGnxWzirQ6?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcHBJZCI6Ijg3NjdFMzIzRjlGQzEzN0E4QTAyIiwiaWF0IjoxNjExMTc4NjAxfQ.epzkpzjkQX6Az6r9TBJfnx0YAImP4rmvFGe55Koo63w"></video>
                                        <button class="set-priority" type="button" data-peer-name="Guest 2"></button>
                                    </li>
                                </ul>
                                <div class="overlay">
                                    <button id="status-pill" type="button">
                                        <span class="no-session">No session has been started.</span>
                                        <span class="session">
                                            <svg class="icon user" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2c2.757 0 5 2.243 5 5.001 0 2.756-2.243 5-5 5s-5-2.244-5-5c0-2.758 2.243-5.001 5-5.001zm0-2c-3.866 0-7 3.134-7 7.001 0 3.865 3.134 7 7 7s7-3.135 7-7c0-3.867-3.134-7.001-7-7.001zm6.369 13.353c-.497.498-1.057.931-1.658 1.302 2.872 1.874 4.378 5.083 4.972 7.346h-19.387c.572-2.29 2.058-5.503 4.973-7.358-.603-.374-1.162-.811-1.658-1.312-4.258 3.072-5.611 8.506-5.611 10.669h24c0-2.142-1.44-7.557-5.631-10.647z" /></svg>
                                            <span class="count">1</span> participants
                                        </span>
                                    </button>
                                    <button id="video-session-key" type="button" title="Copy the session key">
                                        <span class="description">Session Key:</span>
                                        <span class="value"></span>
                                    </button>
                                </div>
                            </div>
                            <aside>
                                <ul class="panels">
                                    <li class="panel peers">
                                        <header>Peers</header>
                                        <div class="content">
                                            <ul id="video-peers">
                                                <li class="peer">Host</li>
                                                <li class="peer">Guest</li>
                                            </ul>
                                        </div>
                                    </li>
                                    <li class="panel messages">
                                        <header>Messages</header>
                                        <div class="content">
                                            <ul id="video-messages">
                                                <li class="status">Test User has joined the chat</li>
                                                <li class="message self">
                                                    <header>
                                                        <span class="name">Host</span>
                                                    </header>
                                                    <div class="content">
                                                        Hola Mundo!
                                                    </div>
                                                </li>
                                                <li class="message">
                                                    <header>
                                                        <span class="name">Test User</span>
                                                    </header>
                                                    <div class="content">
                                                        Hi! I hope this message finds you well!
                                                    </div>
                                                </li>
                                            </ul>
                                            <form id="video-chat-message">
                                                <input class="value" name="message" type="text" placeholder="Send a message..." autocomplete="off" />
                                            </form>
                                        </div>
                                    </li>
                                    <li class="panel controls">
                                        <header>Controls</header>
                                        <div class="content">
                                            <ul id="video-options">
                                                <li id="video-toggle-audio" class="option toggle-audio" title="Mute/Unmute">
                                                    <button type="button">
                                                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M5 17h-5v-10h5v10zm2-10v10l9 5v-20l-9 5zm17 4h-5v2h5v-2zm-1.584-6.232l-4.332 2.5 1 1.732 4.332-2.5-1-1.732zm1 12.732l-4.332-2.5-1 1.732 4.332 2.5 1-1.732z" /></svg>
                                                    </button>
                                                </li>
                                                <li id="video-toggle-webcam" class="option toggle-webcam">
                                                    <button type="button" title="Toggle Webcam">
                                                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M17.387 18.581l3.613 5.419h-18l3.613-5.419c1.594.899 3.429 1.419 5.387 1.419s3.793-.52 5.387-1.419zm-5.387-11.581c-1.103 0-2 .897-2 2s.897 2 2 2 2-.897 2-2-.897-2-2-2zm9 2c0 4.971-4.029 9-9 9s-9-4.03-9-9 4.029-9 9-9 9 4.03 9 9zm-5 0c0-2.209-1.791-4-4-4s-4 1.791-4 4 1.791 4 4 4 4-1.791 4-4z" /></svg>
                                                    </button>
                                                </li>
                                                <li id="video-toggle-screen" class="option toggle-screen">
                                                    <button type="button" title="Toggle Screen Share">
                                                        <svg class="icon" width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd"><path d="M24 8.2c0-.318-.126-.623-.351-.849-.226-.225-.531-.351-.849-.351h-6.6c-.318 0-.623.126-.849.351-.225.226-.351.531-.351.849v13.6c0 .318.126.623.351.849.226.225.531.351.849.351h6.6c.318 0 .623-.126.849-.351.225-.226.351-.531.351-.849v-13.6zm-11 14.8h-8l2.599-3h5.401v3zm6.5-1c-.553 0-1-.448-1-1s.447-1 1-1c.552 0 .999.448.999 1s-.447 1-.999 1zm3.5-3v-9.024h-7v9.024h7zm-2-14h-2v-2h-17v13h11v2h-13v-17h21v4zm-.5 4c.276 0 .5-.224.5-.5s-.224-.5-.5-.5h-2c-.276 0-.5.224-.5.5s.224.5.5.5h2z" /></svg>
                                                    </button>
                                                </li>
                                            </ul>
                                        </div>
                                    </li>
                                </ul>
                            </aside>
                        </div>
                    </div>
                    <div class="setup">
                        <div class="display host">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M3.449 15.19c-.92-1.513-1.449-3.289-1.449-5.189 0-5.523 4.477-10.001 10-10.001s10 4.478 10 10.001c0 1.9-.529 3.676-1.451 5.189.513-1.156.797-2.434.797-3.78 0-5.163-4.184-9.347-9.346-9.347s-9.346 4.185-9.346 9.347c0 1.345.284 2.624.795 3.78zm3.108-3.78c0-3.006 2.438-5.442 5.443-5.442s5.443 2.437 5.443 5.443c0 .696-.133 1.362-.371 1.975.648-.969 1.025-2.132 1.025-3.384 0-3.368-2.73-6.099-6.098-6.099s-6.098 2.73-6.098 6.099c0 1.252.377 2.416 1.025 3.384-.237-.613-.369-1.279-.369-1.976zm6.443 2.59c1.162-.414 2-1.512 2-2.816 0-1.657-1.344-3-3-3s-3 1.343-3 3c0 1.304.838 2.403 2 2.816l-5 10h2.236c.713-1.426 2.17-2.326 3.764-2.326s3.051.9 3.764 2.326h2.236l-5-10zm-2.764 6l1.764-3.528 1.764 3.528h-3.528z" /></svg>
                            <span class="description">Host</span>
                        </div>
                        <div class="display join">
                            <svg class="icon" width="24" height="24" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill-rule="evenodd" clip-rule="evenodd"><path d="M20 15c0 .552-.448 1-1 1s-1-.448-1-1 .448-1 1-1 1 .448 1 1m-3 0c0 .552-.448 1-1 1s-1-.448-1-1 .448-1 1-1 1 .448 1 1m-3 0c0 .552-.448 1-1 1s-1-.448-1-1 .448-1 1-1 1 .448 1 1m5.415 4.946c-1 .256-1.989.482-3.324.482-3.465 0-7.091-2.065-7.091-5.423 0-3.128 3.14-5.672 7-5.672 3.844 0 7 2.542 7 5.672 0 1.591-.646 2.527-1.481 3.527l.839 2.686-2.943-1.272zm-13.373-3.375l-4.389 1.896 1.256-4.012c-1.121-1.341-1.909-2.665-1.909-4.699 0-4.277 4.262-7.756 9.5-7.756 5.018 0 9.128 3.194 9.467 7.222-1.19-.566-2.551-.889-3.967-.889-4.199 0-8 2.797-8 6.672 0 .712.147 1.4.411 2.049-.953-.126-1.546-.272-2.369-.483m17.958-1.566c0-2.172-1.199-4.015-3.002-5.21l.002-.039c0-5.086-4.988-8.756-10.5-8.756-5.546 0-10.5 3.698-10.5 8.756 0 1.794.646 3.556 1.791 4.922l-1.744 5.572 6.078-2.625c.982.253 1.932.407 2.85.489 1.317 1.953 3.876 3.314 7.116 3.314 1.019 0 2.105-.135 3.242-.428l4.631 2-1.328-4.245c.871-1.042 1.364-2.384 1.364-3.75" /></svg>
                            <span class="description">Join</span>
                            <small class="label">Session Key</small>
                            <form id="video-session-key-form">
                                <input class="session-key" type="text" placeholder="xxxxx" title="Session Key" />
                            </form>
                        </div>
                        <div class="choice host">
                            <div class="control">
                                <small class="label">Display Name</small>
                                <form id="video-host-form">
                                    <input class="display-name" type="text" title="Display Name" value="Host" />
                                    <button class="action" type="submit">Host Chat</button>
                                </form>
                            </div>
                            <span class="message">This is an error</span>
                        </div>
                        <div class="choice join">
                            <div class="control">
                                <small class="label">Display Name</small>
                                <form id="video-join-form">
                                    <input class="display-name" type="text" title="Display Name" value="Guest" />
                                    <button class="action" type="submit">Join Chat</button>
                                </form>
                            </div>
                            <span class="message">This is a really long error that should wrap to the next line and still be legible in all circumstances</span>
                        </div>
                    </div>
                </div>
                <script defer type="module">
                    document.addEventListener('DOMContentLoaded', Init);

                    async function Init() {
                        // unlike the text chat, the video chat will be P2P.
                        // that means that all of the peer organization that is
                        // done by the server to facilitate that session will need
                        // to be recreated, here, so that the host client's javascript
                        // can manage the video streaming peers.
                        const videoChat = new VideoChat();
                        videoChat.addEventListener('peers', videoSession_onPeers);
                        videoChat.addEventListener('chatmessage', videoSession_onChatMessage);
                        videoChat.addEventListener('end', videoSession_onEnd);

                        // define well-known html elements
                        const $videoChatroom = document.querySelector('.card.video-chat .chatroom');
                        $videoChatroom.$title = $videoChatroom.querySelector('header > .title');

                        const $videoExitButton = $videoChatroom.querySelector('header > .exit');

                        const $videoStreams = document.getElementById('video-streams');

                        const $videoPeers = document.getElementById('video-peers');

                        const $sessionStatusPill = document.getElementById('status-pill');
                        $sessionStatusPill.$count = $sessionStatusPill.querySelector('.count');

                        const $sessionKeyPill = document.getElementById('video-session-key');
                        $sessionKeyPill.$value = $sessionKeyPill.querySelector('.value');
                        $sessionKeyPill.$input = document.createElement('input');

                        const $videoChatMessages = document.getElementById('video-messages');

                        const $videoChatMessageForm = document.getElementById('video-chat-message');
                        $videoChatMessageForm.$value = $videoChatMessageForm.querySelector('input');

                        const $videoChatSetup = document.querySelector('.card.video-chat .setup');

                        const $videoHostDisplayName = $videoChatSetup.querySelector('.choice.host .display-name');
                        const $videoHostForm = document.getElementById('video-host-form');
                        const $videoHostButton = $videoChatSetup.querySelector('.choice.host .action');
                        const $videoHostErrorMessage = $videoChatSetup.querySelector('.choice.host .message');

                        const $videoSessionKeyForm = document.getElementById('video-session-key-form');
                        const $videoGuestSessionKey = $videoChatSetup.querySelector('.display.join .session-key');
                        const $videoGuestDisplayName = $videoChatSetup.querySelector('.choice.join .display-name');
                        const $videoJoinForm = document.getElementById('video-join-form');
                        const $videoJoinButton = $videoChatSetup.querySelector('.choice.join .action');
                        const $videoJoinErrorMessage = $videoChatSetup.querySelector('.choice.join .message');

                        const $videoToggleAudio = document.getElementById('video-toggle-audio');
                        const $videoToggleWebcam = document.getElementById('video-toggle-webcam');
                        const $videoToggleScreen = document.getElementById('video-toggle-screen');

                        let $videoSessionKeyInput = null;
                        let _$videoMessageDisplay = null;

                        // add functionality
                        $videoExitButton.addEventListener('click', videoExitChat_onClick);
                        $videoHostForm.addEventListener('submit', videoHostSession_onSubmit);
                        $videoSessionKeyForm.addEventListener('submit', videoJoinSession_onSubmit);
                        $videoJoinForm.addEventListener('submit', videoJoinSession_onSubmit);
                        $videoChatMessageForm.addEventListener('submit', videoChatMessageForm_onSubmit);
                        $sessionKeyPill.addEventListener('click', sessionKeyPill_OnClick);

                        $videoToggleAudio.addEventListener('click', videoToggleAudio_OnClick);
                        $videoToggleWebcam.addEventListener('click', videoToggleWebcam_OnClick);
                        $videoToggleScreen.addEventListener('click', videoToggleScreen_OnClick);


                        // prepare page for new chat session
                        resetVideoSession();

                        // handlers
                        function videoSession_onPeers(event) {
                            updateVideoChatPeers();
                            updateVideoChatStreams();

                            // show messages
                            let peersAdded = event.detail.added;
                            for (let i = 0; i < peersAdded.length; i++) {
                                let videoPeer = peersAdded[i];
                                let peerToken = videoPeer.token;
                                if (videoChat.isHost == false) {
                                    let displayName = (peerToken.DisplayName == '') ? `[${peerToken.PeerId}]` : peerToken.DisplayName;
                                    let content = `<div>${displayName} has joined the chat.</div>`;
                                    let $joinMessage = addVideoChatStatus(content);
                                }
                            }

                            let peersRemoved = event.detail.removed;
                            for (let i = 0; i < peersRemoved.length; i++) {
                                let videoPeer = peersRemoved[i];
                                let peerToken = videoPeer.token;
                                let displayName = (peerToken.DisplayName == '') ? `[${peerToken.PeerId}]` : peerToken.DisplayName;
                                let action = (videoChat.isHost == true) ? 'ended' : 'left';
                                let content = `<div>${displayName} has ${action} the chat.</div>`;
                                let $leaveMessage = addVideoChatStatus(content);
                            }
                        }
                        function videoSession_onChatMessage(event) {
                            addVideoChatMessage(event.detail);
                        }
                        function videoSession_onEnd(event) {

                            addVideoChatStatus(event.detail.closingMessage);
                            clearVideoChatStreams();
                            setVideoSessionState(false);
                        }

                        async function videoHostSession_onSubmit(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            try {
                                _$videoMessageDisplay = $videoHostErrorMessage;

                                resetVideoSession();

                                await videoChat.host($videoHostDisplayName.value);

                                prepareVideoSession();

                                $videoExitButton.removeAttribute('disabled');
                                $videoHostButton.setAttribute('disabled', 'disabled');
                                $videoJoinButton.setAttribute('disabled', 'disabled');

                                $videoChatroom.classList.add('in-session');
                            }
                            catch (exception) {
                                resetVideoSession();
                                showVideoChatError($videoHostErrorMessage, exception);
                            }
                            finally {
                                _$videoMessageDisplay = null;
                                return false;
                            }
                        }

                        async function videoJoinSession_onSubmit(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            try {
                                _$videoMessageDisplay = $videoJoinErrorMessage;

                                resetVideoSession();

                                await videoChat.join($videoGuestSessionKey.value, $videoGuestDisplayName.value);

                                prepareVideoSession();

                                $videoExitButton.removeAttribute('disabled');
                                $videoJoinButton.setAttribute('disabled', 'disabled');
                                $videoHostButton.setAttribute('disabled', 'disabled');

                                $videoChatroom.classList.add('in-session');
                            }
                            catch (exception) {
                                resetVideoSession();
                                showVideoChatError($textJoinErrorMessage, exception);
                            }
                            finally {
                                _$videoMessageDisplay = null;
                                return false;
                            }
                        }
                        async function videoExitChat_onClick(event) {

                            await videoChat.endSession();

                            $videoHostButton.removeAttribute('disabled');
                            $videoJoinButton.removeAttribute('disabled');
                            $videoExitButton.setAttribute('disabled', 'disabled');
                        }

                        async function videoChatMessageForm_onSubmit(event) {
                            event.preventDefault();
                            event.stopPropagation();

                            if (videoChat.signalingSession == null) {
                                console.error("No session has been started.");
                                return false;
                            }

                            console.log("Sending to server");
                            addVideoChatMessage({ SenderId: videoChat.signalingSession.token.PeerId, Message: $videoChatMessageForm.$value.value });
                            videoChat.sendChatMessage($videoChatMessageForm.$value.value);

                            $videoChatMessageForm.$value.value = '';
                            return false;
                        }

                        function sessionKeyPill_OnClick(event) {
                            copyTextToClipboard($sessionKeyPill.$value.textContent);
                            addVideoChatStatus('Copied the Session Key');
                        }

                        function videoToggleAudio_OnClick(event) {
                            toggleMute();
                        }
                        function videoToggleWebcam_OnClick(event) {
                            toggleWebcam();
                        }
                        function videoToggleScreen_OnClick(event) {
                            toggleScreenShare();
                        }

                        // functionality
                        function resetVideoSession() {
                            setVideoSessionState(false);
                            clearVideoChatStreams();
                            clearVideoChatHistory();
                            clearVideoChatErrors();
                        }
                        function prepareVideoSession() {
                            setVideoSessionState(true);

                            let introMessage = '';
                            let hostName = (videoChat.signalingSession.hostToken.DisplayName || 'Host');
                            if (videoChat.signalingSession.token.PeerId == videoChat.signalingSession.hostToken.PeerId) {
                                introMessage = `You (${hostName}) have started a video chat session.`;
                            }
                            else {
                                introMessage = `You have joined ${hostName}'s chat.`;
                            }
                            $videoChatroom.$title.textContent = hostName + '\'s text chat';
                            videoChat.signalingSession.peerTokens[videoChat.signalingSession.token.PeerId] = Object.assign({}, videoChat.signalingSession.token);
                            clearVideoChatHistory();
                            updateVideoChatPeers();

                            addVideoChatStatus(introMessage);
                            displayVideoSessionKey(videoChat.signalingSession.sessionKey);

                            requestWebcam();
                        }

                        function setVideoSessionState(inSession) {
                            if (inSession == true) {
                                $videoChatroom.classList.add('in-session');
                            }
                            else {
                                $videoChatroom.classList.remove('in-session');
                                $videoChatroom.$title.textContent = '';
                                clearVideoChatPeers();
                                $videoHostButton.removeAttribute('disabled');
                                $videoJoinButton.removeAttribute('disabled');
                            }
                        }

                        function toggleWebcam() {
                            if (videoChat.isStreamingWebcam == true) {
                                videoChat.endLocalWebcamStream();
                            }
                            else {
                                requestWebcam();
                            }
                        }
                        async function requestWebcam() {
                            console.log('Requesting local webcam stream');
                            try {
                                const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, ampleRate: 44100 }, video: { width: 1280, height: 720 } });
                                console.log('Received local webcam stream');
                                videoChat.setLocalWebcamStream(stream);
                            }
                            catch (exception) {
                                console.error(`getUserMedia() error: ${exception.name}`);
                            }
                        }

                        function toggleMute() {
                            if (videoChat.isMuted == true) {
                                videoChat.unmuteLocalAudio();
                            }
                            else {
                                videoChat.muteLocalAudio();
                            }
                        }

                        function toggleScreenShare() {
                            if (videoChat.isStreamingScreen == true) {
                                videoChat.endLocalScreenStream();
                            }
                            else {
                                requestScreenStream();
                            }
                        }
                        async function requestScreenStream() {
                            console.log('Requesting local screen stream');
                            try {
                                const stream = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: 'always' }, audio: false });
                                console.log('Received local screen stream');
                                videoChat.beginLocalScreenStream(stream);
                            }
                            catch (exception) {
                                console.error(`getUserMedia() error: ${exception.name}`);
                            }
                        }

                        function clearVideoChatErrors() {
                            $videoHostErrorMessage.textContent = '';
                            $videoJoinErrorMessage.textContent = '';
                        }
                        function clearVideoChatHistory() {
                            while ($videoChatMessages.lastChild) {
                                $videoChatMessages.lastChild.remove();
                            }
                        }
                        function updateVideoChatStreams() {
                            clearVideoChatStreams();

                            for (let property in videoChat.signalingPeers) {

                                let peer = videoChat.signalingPeers[property];
                                if (peer.token.PeerId == videoChat.hostPeer.token.PeerId) {
                                    peer.$element.classList.add('host');
                                }
                                if (peer.token.PeerId == videoChat.clientPeer.token.PeerId) {
                                    peer.$element.classList.add('self');
                                }
                                $videoStreams.appendChild(peer.$element);
                            }
                        }
                        function clearVideoChatStreams() {
                            while ($videoStreams.lastChild) {
                                $videoStreams.lastChild.remove();
                            }
                        }
                        function updateVideoChatPeers() {
                            clearVideoChatPeers();

                            for (let property in videoChat.signalingPeers) {

                                let peer = videoChat.signalingPeers[property];
                                let displayName = (peer.token.DisplayName == '') ? `[${peer.token.PeerId}]` : peer.token.DisplayName;
                                let $peer = document.createElement('li');
                                $peer.classList.add('peer');
                                if (peer.token.PeerId == videoChat.hostPeer.token.PeerId) {
                                    $peer.classList.add('host');
                                }
                                if (peer.token.PeerId == videoChat.clientPeer.token.PeerId) {
                                    $peer.classList.add('self');
                                }
                                $peer.textContent = displayName;
                                $videoPeers.appendChild($peer);
                            }

                            let peerTokenCount = Object.keys(videoChat.signalingPeers)?.length
                            $sessionStatusPill.$count.textContent = peerTokenCount;
                        }
                        function clearVideoChatPeers() {
                            while ($videoPeers.lastChild) {
                                $videoPeers.lastChild.remove();
                            }
                            $sessionStatusPill.$count.textContent = '';
                        }
                        function addVideoChatStatus(statusMessage) {
                            let $message = document.createElement('li');
                            $message.classList.add('status');
                            $message.innerHTML = statusMessage;

                            $videoChatMessages.appendChild($message);
                            return $message;
                        }
                        function displayVideoSessionKey(sessionKey) {

                            $sessionKeyPill.$value.textContent = sessionKey;
                        }
                        function addVideoChatMessage(messageData) {
                            let $message = document.createElement('li');
                            $message.classList.add('message');

                            let content;
                            if (Object.prototype.toString.call(messageData) === '[object String]') {
                                content = `${messageData}`;
                            }
                            else {
                                let peer = (messageData.SenderId == videoChat.signalingSession.token.PeerId) ? videoChat.signalingSession.token : videoChat.signalingSession.peerTokens[messageData.SenderId];
                                if (peer == null) {
                                    console.error('Unknown Participant. Socket ID: ' + messageData.SenderId);
                                    return;
                                }

                                if (peer == videoChat.signalingSession.token) {
                                    $message.classList.add('self');
                                }

                                content = `<header><span class="name">${peer.DisplayName}</span></header>
                                                                            <div class="content">
                                                                                ${messageData.Message}
                                                                            </div>`;
                            }

                            $message.innerHTML = content;

                            $videoChatMessages.appendChild($message);

                            $videoChatMessages.scrollTop = $videoChatMessages.scrollHeight - $videoChatMessages.getBoundingClientRect().height;
                            return $message;
                        }
                        function showVideoChatError($target, error) {
                            console.error(error);
                            $target.textContent = 'An error has occurred. Please see the console for more details.';
                        }

                        function copyTextToClipboard(value) {
                            if ($videoSessionKeyInput == null) {
                                $videoSessionKeyInput = document.createElement('input');
                                $videoSessionKeyInput.style.top = "-9000px";
                                $videoSessionKeyInput.style.left = "-9000px";
                                $videoSessionKeyInput.style.position = "fixed";
                            }

                            $videoSessionKeyInput.value = value;
                            document.body.appendChild($videoSessionKeyInput);
                            try {
                                $videoSessionKeyInput.select();
                                $videoSessionKeyInput.setSelectionRange(0, 99999);
                                document.execCommand('copy');
                            }
                            catch (error) {
                                console.error(error);
                            }
                            $videoSessionKeyInput.remove();
                        }
                    }


                    // this class abstracts that host management functionality
                    // away from the UI interactions.
                    class VideoChat {

                        constructor() {
                            // establish a well-known variable
                            // to hold the websocket session
                            this.signalingSession = this.createSignalingSession();

                            this.resetState();

                            this.configuration = {
                                iceServers: [
                                    {
                                        urls: "stun:stun.l.google.com:19302" // this is an example server, but you should set up your own STUN/TURN servers
                                    }
                                ]
                            };

                            // easy event forwarding
                            let node = document.createTextNode(null);
                            this.addEventListener = node.addEventListener.bind(node);
                            this.removeEventListener = node.removeEventListener.bind(node);
                            this.dispatchEvent = node.dispatchEvent.bind(node);

                            // this is used as the event handler for whenever a user
                            // clicks on the "stop sharing" button that is native to
                            // a browser; Rather than bind the function every time
                            // or write an anoynymous function each time, I'm just
                            // binding once and assiging it as the handler (this is
                            // not really good practice. Use handlers to handle and then call functions
                            // to perform the work. But that's a rule and this is an exception.)
                            this.boundEndLocalScreenStream = this.endLocalScreenStream.bind(this);
                        }
                        resetState() {
                            this.signalingPeers = new Map();
                            this.clientPeer = null;
                            this.hostPeer = null;

                            this.isHost = false;
                            this.isStreamingWebcam = false;
                            this.isStreamingMicrophone = false;
                            this.isStreamingScreen = false;
                            this.isMuted = false;

                            this.hasPeerConnection = false;
                        }

                        // handlers
                        signalingSession_OnPeers(event) {

                            const { peersAdded, peersRemoved } = this.updateVideoPeers(false);

                            this.updatePeerStreams(peersAdded);

                            let actionEvent = new CustomEvent('peers', { detail: { peers: this.signalingPeers.entries(), added: peersAdded, removed: peersRemoved } });
                            this.dispatchEvent(actionEvent);

                        }
                        async signalingSession_OnMessage(event) {

                            const message = event.detail;
                            if (message.SenderId == this.clientPeer.token.PeerId) {
                                return;
                            }

                            const data = JSON.parse(message.Message);

                            if (data.type == 'chatmessage') {
                                const messageEvent = new CustomEvent('chatmessage', { detail: { SenderId: message.SenderId, Message: data.value } });
                                this.dispatchEvent(messageEvent);
                                return;
                            }
                            else if (data.type == 'candidate') {
                                try {
                                    let videoPeer = this.signalingPeers.get(message.SenderId);
                                    if (videoPeer != null) {
                                        videoPeer.addIceCandidate(data.candidate);
                                    }
                                } catch (error) {
                                    console.log(`Failed to add ice candidate: ${error.toString()}`);
                                }
                            }
                            else if (data.type == 'description') {
                                let videoPeer = this.signalingPeers.get(message.SenderId);
                                if (videoPeer != null) {
                                    videoPeer.setDescription(data.description, this.sendValue.bind(this));
                                }
                            }
                        }
                        signalingSession_OnStatusUpdates(event) {
                            console.log(event);
                        }
                        signalingSession_OnClose(event) {
                            let closingMessage = '[The chat session has been ended.]';
                            if (this.signalingSession.requestedEnd == true) {
                                let action = (this.signalingSession.token.PeerId == this.signalingSession.hostToken.PeerId) ? 'ended' : 'left';
                                closingMessage = `[You have ${action} the chat session.]`;
                            }

                            this.signalingSession = null;

                            // dispatch events
                            let actionEvent = new CustomEvent('end', { detail: { closingMessage } });
                            this.dispatchEvent(actionEvent);
                        }
                        signalingSession_OnError(event) {
                            if (_$messageDisplay != null) {
                                _$messageDisplay.textContent = "An error occurred while trying to connect to the session. If you are trying to join, please check the session key and try again."
                            }
                            console.log(event);
                        }


                        handle_ice_onCandidate(peerId, event, signalingType, connectionType) {
                            console.log('ICE Candidate event: ', event);
                            this.sendValue({ type: 'candidate', candidate: event.candidate, signalingType: signalingType, connectionType: connectionType }, null, peerId);
                        }
                        handle_ice_onConnected() {
                            let action = new CustomEvent('connected');
                            this.dispatchEvent(action);
                        }
                        handle_ice_onNegotiationNeeded(peerId, event, description, connectionType) {
                            this.sendValue({ type: 'description', description: description, connectionType: connectionType }, null, peerId);
                        }

                        // functionality
                        async host(displayName) {
                            await this.connect('host', displayName);
                            this.isHost = true;
                            this.clientPeer.isPolite = false;
                        }
                        async join(sessionKey, displayName) {
                            return this.connect('join', sessionKey, displayName);
                        }
                        async connect(method, ...args) {

                            if (this.signalingSession == null) {
                                this.signalingSession = this.createSignalingSession();
                            }

                            // get signaling session
                            await this.signalingSession[method](...args);
                            this.signalingSession.socket.binaryType = 'arraybuffer';

                            this.updateVideoPeers();
                        }

                        createSignalingSession() {
                            let session = new WebsocketSession();
                            session.addEventListener('peers', this.signalingSession_OnPeers.bind(this));
                            session.addEventListener('message', this.signalingSession_OnMessage.bind(this));
                            session.addEventListener('statusupdates', this.signalingSession_OnStatusUpdates.bind(this));
                            session.addEventListener('close', this.signalingSession_OnClose.bind(this));
                            session.addEventListener('error', this.signalingSession_OnError.bind(this));
                            return session;
                        }

                        async endSession() {

                            // end streams
                            for (const [peerId, videoPeer] of this.signalingPeers.entries()) {
                                this.removePeer(peerId);
                            }

                            // end the signaling session
                            this.signalingSession.requestedEnd = true;
                            await this.signalingSession.close();
                            this.resetState();
                        }


                        setLocalWebcamStream(stream) {

                            this.clientPeer.$video.srcObject = stream;
                            this.clientPeer.localWebcamStream = stream;
                            this.isStreamingWebcam = true;

                            for (let [peerId, videoPeer] of this.signalingPeers.entries()) {
                                if (videoPeer != this.clientPeer) {
                                    videoPeer.addStream(stream);
                                }
                            }
                        }
                        endLocalWebcamStream() {
                            this.clientPeer.$video.pause();
                            this.clientPeer.$video.srcObject = null;

                            for (let [peerId, videoPeer] of this.signalingPeers.entries()) {
                                if (videoPeer != this.clientPeer) {
                                    videoPeer.removeStream('webcam');
                                }
                            }

                            this.clientPeer.removeStream('webcam');
                            this.clientPeer.localWebcamStream = null;
                            this.isStreamingWebcam = false;
                        }
                        beginLocalScreenStream(stream) {
                            this.clientPeer.$screenshare.style.display = 'initial';
                            this.clientPeer.$screenshare.srcObject = stream;
                            this.clientPeer.localScreenStream = stream;
                            this.isStreamingScreen = true;

                            // handle the case that the user clicked
                            // the browser's "stop sharing" button
                            // instead of using the ui button
                            stream.getVideoTracks()[0].onended = this.boundEndLocalScreenStream;

                            for (let [peerId, videoPeer] of this.signalingPeers.entries()) {
                                if (videoPeer != this.clientPeer) {
                                    videoPeer.addStream(stream, 'screen');
                                }
                            }
                        }
                        endLocalScreenStream() {
                            this.clientPeer.$screenshare.pause();
                            this.clientPeer.$screenshare.srcObject = null;
                            this.clientPeer.$screenshare.style.display = 'none';
                            this.clientPeer.removeStream('screen');
                            this.clientPeer.localScreenStream = null;

                            for (let [peerId, videoPeer] of this.signalingPeers.entries()) {
                                if (videoPeer != this.clientPeer) {
                                    videoPeer.removeStream('screen');
                                }
                            }

                            this.isStreamingScreen = false;
                        }
                        endStreaming() {
                            this.endLocalWebcamStream();
                            this.endLocalScreenStream();
                        }

                        sendChatMessage(message) {
                            const chatMessage = { type: 'chatmessage', value: message };
                            this.sendValue(chatMessage);
                        }
                        sendValue(value, type, recipients) {
                            this.sendMessage(JSON.stringify(value), type, recipients);
                        }
                        sendMessage(message, type, recipients) {
                            type = type || 8;
                            if (recipients != null) {
                                if (!Array.isArray(recipients)) {
                                    recipients = [recipients];
                                }
                            }
                            this.signalingSession.send(JSON.stringify({ Type: type, SenderId: this.clientPeer.token.PeerId, Message: message, Recipients: recipients }))
                        }
                        sendBinary(buffer) {
                            this.signalingSession.send(buffer);
                        }


                        updateVideoPeers(dispatchEvent = true) {
                            // add or update new peers
                            const peersAdded = [];
                            for (let property in this.signalingSession.peerTokens) {
                                if (this.signalingSession.peerTokens.hasOwnProperty(property)) {
                                    let peerToken = this.signalingSession.peerTokens[property];
                                    let videoPeer = this.signalingPeers.get(peerToken.PeerId);
                                    if (videoPeer == null) {
                                        videoPeer = this.addPeer(peerToken);
                                        peersAdded.push(videoPeer);
                                    }
                                    this.updatePeer(videoPeer, peerToken, false);
                                }
                            }

                            // remove the peers that are no longer in the session
                            const peersRemoved = [];
                            for (const [peerId, videoPeer] of this.signalingPeers.entries()) {

                                let peerToken = this.signalingSession.peerTokens[peerId];
                                if (peerToken == null) {
                                    peersRemoved.push(videoPeer);
                                    this.removePeer(peerId, false);
                                }
                            }

                            if (dispatchEvent == true) {
                                let actionEvent = new CustomEvent('peers', { detail: { peers: this.signalingPeers.entries(), added: peersAdded, removed: peersRemoved } });
                                this.dispatchEvent(actionEvent);
                            }

                            return { peersAdded, peersRemoved };
                        }
                        addPeer(peerToken) {
                            const videoPeer = new VideoPeer(peerToken, this.configuration, this.handle_ice_onConnected.bind(this), this.handle_ice_onCandidate.bind(this), this.handle_ice_onNegotiationNeeded.bind(this));
                            this.signalingPeers.set(peerToken.PeerId, videoPeer);
                            return videoPeer;
                        }
                        updatePeer(videoPeer, dispatchEvent = true) {

                            if (videoPeer.token.PeerId == this.signalingSession.token.PeerId) {
                                this.clientPeer = videoPeer;
                            }
                            if (videoPeer.token.PeerId == this.signalingSession.hostToken.PeerId) {
                                this.hostPeer = videoPeer;
                            }

                            this.signalingPeers[videoPeer.token.PeerId] = videoPeer;

                            if (dispatchEvent == true) {
                                let actionEvent = new CustomEvent('peers', { detail: this.signalingPeers });
                                this.dispatchEvent(actionEvent);
                            }
                        }
                        removePeer(peerId, dispatchEvent = true) {
                            const videoPeer = this.signalingPeers.get(peerId);
                            if (videoPeer != null) {
                                videoPeer.endStreams();
                                this.signalingPeers.delete(peerId);
                            }

                            if (dispatchEvent == true) {
                                let actionEvent = new CustomEvent('peers', { detail: this.signalingPeers });
                                this.dispatchEvent(actionEvent);
                            }
                        }

                        async updatePeerStreams(connections) {
                            for (let i = 0; i < connections.length; i++) {
                                const videoPeer = connections[i];
                                if (this.clientPeer.localWebcamStream != null) {
                                    videoPeer.addStream(this.clientPeer.localWebcamStream);
                                }
                                if (this.clientPeer.localScreenStream) {
                                    videoPeer.addStream(this.clientPeer.localScreenStream, 'screen');
                                }
                            }
                        }

                        muteLocalAudio() {
                            this.clientPeer.$video.muted = true;

                            for (let [peerId, videoPeer] of this.signalingPeers.entries()) {
                                if (videoPeer != this.clientPeer) {
                                    videoPeer.muteLocalAudio();
                                }
                            }
                            this.isMuted = true;
                        }
                        unmuteLocalAudio() {
                            this.clientPeer.$video.muted = false;

                            for (let [peerId, videoPeer] of this.signalingPeers.entries()) {
                                if (videoPeer != this.clientPeer) {
                                    videoPeer.unmuteLocalAudio();
                                }
                            }
                            this.isMuted = false;
                        }
                    }

                    // a helper class for organizing peer data in video chats
                    class VideoPeer {
                        constructor(peerToken, configuration, iceConnectedCallback, iceCandidateCallback, onNegotiationNeededCallback) {

                            this.isPolite = true;

                            this.token = peerToken;
                            this.configuration = configuration;
                            this.iceCandidateCallback = iceConnectedCallback;
                            this.iceCandidateCallback = iceCandidateCallback;

                            this.remoteStream = null;
                            this.localWebcamStream = null;

                            // these are for managing ended streams;
                            // apparently there's no way for a peer to
                            // know that the connected peer has stopped
                            // streaming, other than to check the packet
                            // count of the incoming stream?
                            this.statsIntervalMs = 1000;
                            this.statsInterval = null;
                            this.samePacketCountThreshold = 2;
                            this.samePacketWebcamCount = 0;
                            this.samePacketScreenCount = 0;
                            this.remoteWebcamPacketsReceived = 0;
                            this.remoteScreenPacketsReceived = 0;

                            this.isStable = false;
                            this.isMakingOffer = false;
                            this.ignoreOffer = false;
                            this.srdAnswerPending = false;


                            this.peerConnection = new RTCPeerConnection(configuration);
                            this.peerConnection.ontrack = (event) => {
                                console.log('track: ', event);
                                if (this.remoteStream == null || this.remoteStream.id != event.streams[0].id) {
                                    this.remoteStream = new MediaStream();
                                }
                                this.remoteStream.addTrack(event.track);

                                const videoTrack = this.remoteStream.getVideoTracks()[0];
                                if (videoTrack != null) {
                                    this.statsInterval = setInterval(async () => {
                                        const stats = await this.peerConnection.getStats(videoTrack);
                                        const statsArray = [];
                                        for (const [key, stat] of stats) {
                                            if (stat.type == 'inbound-rtp' && stat.isRemote == false) {
                                                if (stat.packetsReceived == this.remoteWebcamPacketsReceived) {
                                                    if (this.samePacketWebcamCount == this.samePacketCountThreshold) {
                                                        this.$video.pause();
                                                        this.$video.src = null;
                                                        this.remoteStream = null;
                                                        clearInterval(this.statsInterval);
                                                    }
                                                    else {
                                                        this.samePacketWebcamCount++;
                                                    }
                                                }
                                                this.remoteWebcamPacketsReceived = stat.packetsReceived;
                                            }
                                        }
                                    }, this.statsIntervalMs);
                                }
                                this.$video.srcObject = this.remoteStream;
                            };
                            this.peerConnection.onicecandidate = (event) => {
                                if (event.candidate != null && iceCandidateCallback != null) {
                                    iceCandidateCallback(this.token.PeerId, event);
                                }
                            };
                            this.peerConnection.oniceconnectionstatechange = (event) => {
                                console.log('ICE state change event: ', event);
                                if (this.peerConnection.iceConnectionState == 'connected') {
                                    if (iceConnectedCallback != null) {
                                        iceConnectedCallback();
                                    }
                                }
                                else if (this.peerConnection.iceConnectionState == 'failed') {
                                    this.peerConnection.restartIce();
                                }
                            };
                            this.peerConnection.onnegotiationneeded = async (event) => {
                                try {
                                    console.log('SLD due to negotiationneeded');
                                    this.isMakingOffer = true;
                                    await this.peerConnection.setLocalDescription();
                                    if (onNegotiationNeededCallback != null) {
                                        onNegotiationNeededCallback(this.token.PeerId, event, this.peerConnection.localDescription);
                                    }
                                }
                                catch (error) {
                                    console.error(error);
                                }
                                finally {
                                    this.isMakingOffer = false;
                                }
                            };

                            this.$element = document.createElement('li');
                            this.$element.classList.add('video-stream');
                            this.$element.innerHTML = `<video class="webcam" autoplay></video><video class="screen" autoplay></video><button class="set-priority" type="button" title="Expand" data-peer-name="${peerToken.DisplayName}"></button>`
                            this.$video = this.$element.querySelector('video.webcam');
                            this.$setPriority = this.$element.querySelector('button');
                            this.$screenshare = this.$element.querySelector('video.screen');

                            this.$element.objectRef = this;

                        }

                        // handlers

                        // functionality
                        async addIceCandidate(candidate) {

                            try {
                                await this.peerConnection.addIceCandidate(candidate);
                            } catch (error) {
                                if (this.ignoreOffer == false) {
                                    console.error(`Failed to add ice candidate: ${error.toString()}`);
                                }
                            }
                        }

                        async setDescription(description, sendValueMethod) {
                            this.isStable = this.peerConnection.signalingState == 'stable' || (this.peerConnection.signalingState == 'have-local-offer' && this.srdAnswerPending);
                            this.ignoreOffer = description.type == 'offer' && (this.isPolite == false && (this.isMakingOffer == true || this.isStable == false));
                            if (this.ignoreOffer == true) {
                                console.log('glare - ignoring offer');
                                return;
                            }
                            this.srdAnswerPending = description.type == 'answer';
                            console.log(`SRD(${description.type})`);
                            await this.peerConnection.setRemoteDescription(description);
                            if (description.type == 'offer') {
                                console.log('SLD to get back to stable');
                                await this.peerConnection.setLocalDescription();
                                if (sendValueMethod != null) {
                                    sendValueMethod({ type: 'description', description: this.peerConnection.localDescription }, null, this.token.PeerId);
                                }
                            }
                            else {
                                // answer was set; fire event?
                            }
                        }

                        addStream(stream, type = 'webcam') {
                            if (type == 'webcam') {
                                this.localWebcamStream = stream;
                            }
                            else if (type == 'screen') {
                                this.localScreenStream = stream;
                            }
                            stream.getTracks().forEach(track => {
                                this.peerConnection.addTrack(track, stream);
                            });
                        }
                        removeStream(type = 'webcam') {
                            const stream = (type == 'webcam') ? this.localWebcamStream : this.localScreenStream;
                            if (stream != null) {
                                stream.getTracks().forEach(track => { track.stop(); });
                            }
                        }

                        muteLocalAudio(type = 'webcam') {
                            const stream = (type == 'webcam') ? this.localWebcamStream : this.localScreenStream;
                            if (stream != null) {
                                stream.getAudioTracks().forEach(track => {
                                    track.enabled = false;
                                });
                            }
                        }
                        unmuteLocalAudio(type = 'webcam') {
                            const stream = (type == 'webcam') ? this.localWebcamStream : this.localScreenStream;
                            if (stream != null) {
                                stream.getAudioTracks().forEach(track => {
                                    track.enabled = true;
                                });
                            }
                        }

                        setRemoteStream(type = 'webcam') {
                            const stream = (type == 'webcam') ? this.remoteWebcamStream : this.remoteScreenStream;
                        }
                        clearRemoteStream(type = 'webcam') {
                            const stream = (type == 'webcam') ? this.remoteWebcamStream : this.remoteScreenStream;
                        }

                        async closeConnection(peerConnection) {

                            if (peerConnection) {
                                peerConnection.ontrack = null;
                                peerConnection.onremovetrack = null;
                                peerConnection.onremovestream = null;
                                peerConnection.onicecandidate = null;
                                peerConnection.oniceconnectionstatechange = null;
                                peerConnection.onsignalingstatechange = null;
                                peerConnection.onicegatheringstatechange = null;
                                peerConnection.onnegotiationneeded = null;

                                await peerConnection.close();
                                peerConnection = null;
                            }
                        }

                        pauseWebcam() {
                            this.$video.pause();
                        }
                        playWebcam() {
                            this.$video.play();
                        }
                        pauseScreenshare() {
                            this.$screenshare.pause();
                        }
                        playScreenshare() {
                            this.$screenshare.pause();
                        }

                        async endStreams() {
                            await Promise.allSettled([this.endLocalStreams(), this.endRemoteStreams()]);
                        }
                        async endLocalStreams() {
                            await Promise.allSettled([this.endStream(this.localWebcamStream), this.endScreenStream(this.localScreenStream)]);
                        }
                        async endRemoteStreams() {
                            await Promise.allSettled([this.endStream(this.remoteWebcamStream), this.endScreenStream(this.remoteScreenStream)]);
                        }
                        async endStream(stream) {
                            try {
                                if (stream != null) {
                                    let tracks = await stream.getTracks();
                                    for (const track of tracks) {
                                        track.stop();
                                    }
                                }
                            }
                            catch (error) {
                                console.error(new Error("Unable to stop stream track for peer:"));
                                console.error(error);
                            }
                        }
                    }
                </script>
            </div>

        </div>
    <footer class="full-width">
    </footer>
</main>
</body>

</html>