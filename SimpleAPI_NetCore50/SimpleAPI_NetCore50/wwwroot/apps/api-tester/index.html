<html>
<body>
    <h1>API Tester</h1>
    <h3>This page is for testing non-REST functionality, including file streaming, websocket, and WebRTC sessions.</h3>
    <h3>For testing any standard REST endpoints, please use the OpenAPI route (this can be set as the default in launchsettings.json)</h3>
    <div class="card">
        <form enctype="multipart/form-data" method="post">
            <dl>
                <dt>
                    <label>File</label>
                </dt>
                <dd>
                    <input name="uploadfile" type="file">
                </dd>
            </dl>
        </form>
        <button class="websocket-test" type="button">Test Websocket</button>
        <div>
            <span>Progress:</span><span class="progress-value"></span><span>/</span><span class="progress-total"></span>
        </div>
        <div>
            <progress id="progress-percent" min="0" max="100" step="1" value="0"></progress>
        </div>
    </div>
    <div class="card">
        <header>
            <h2>Messaging</h2>
            <div>
                <h4>Participants</h4>
                <ul id="messaging-participants"></ul>
            </div>
            <div>
                <span>
                    <span class="title">Display Name:</span>
                    <input id="chat-display-name" type="text" value="Host" />
                </span>
                <button id="start-chat" type="button">Start Chat</button>
                <button id="end-chat" type="button">End Chat</button>
            </div>
            <div>
                <span class="title">Session Key:</span>
                <input id="chat-session-key" type="text" placeholder="Start a chat session to generate a key." disabled />
            </div>
        </header>
        <ul id="message-history"></ul>
        <div>
            <textarea id="message"></textarea>
            <button id="send-message" type="button">Send</button>
        </div>
    </div>
    <div class="card video-chat">
    </div>
    <template id="video-chat-ui">
        <div>
            <h4>Peers</h4>
            <ul id="video-peers"></ul>
        </div>
        <div class="display">
            <ul class="videos">
                <li class="video peer host">
                    <video width="800" height="450" id="client-webcam" autoplay></video>
                </li>
            </ul>
            <ul id="toasts"></ul>
        </div>
        <div>
            <button id="get-webcam-feed" type="button">Get Webcam Feed</button>
            <span>
                <span class="title">Display Name:</span>
                <input id="video-display-name" type="text" value="Host" />
            </span>
        </div>
        <div>
            <button id="start-video-chat" type="button">Start Session</button>
            <button id="end-video-chat" type="button">End Session</button>
            <div>
                <span class="title">Session Key:</span>
                <input id="host-session-key" type="text" placeholder="Start a video chat session to generate a key." disabled />
            </div>
        </div>
        <div>
            <button id="join-video-chat" type="button">Join</button>
            <button id="leave-video-chat" type="button">Leave</button>
            <div>
                <span class="title">Session Key:</span>
                <input id="guest-session-key" type="text" />
            </div>
        </div>
    </template>
    <script>
        var apiDomain = new URL(window.location).host;
        var chatSession = null;
        var videoSignalingSession = null;
        var progressSession = null;

        var isHost = false;
        var localStream = null;
        var localPeerOffer = null;
        var localPeerConnection = null;
        var localPeerDescriptionSet = false;
        var remotePeerConnections = {};
        var lobbyPeerConnections = {};

        const socketMessageTypeMap =
            [
                'Unknown', // error checking
                'Greeting', // sending the initial session token and host token
                'Introduction', // for gaining access to channels / providing user data like name/profile pic
                'Heartbeat', // keep-alive signals
                'Properties', // for properties like the participants list or the host id
                'StatusUpdates', // users joined/users left/users are typing/users are asleep/etc
                'Notifications', // relationship added/username tagged/ etc
                'Reaction', // reaction to a message
                'Text', // Text message
                'FormattedText', // Text message that should be handled with special cases
                'Url', // images/videos/audio/media/files anything linked via url
                'ByteArray' // binary data
            ];
        class WebsocketSession {
            constructor() {
                this.domain = new URL(window.location).host;

                this.socket = null;
                this.token = null;
                this.hostToken = null;
                this.peerTokens = {};
                this.offer = null;

                // easy event forwarding
                let node = document.createTextNode(null);
                this.addEventListener = node.addEventListener.bind(node);
                this.removeEventListener = node.removeEventListener.bind(node);
                this.dispatchEvent = node.dispatchEvent.bind(node);
            }

            async host(displayName, iconUrl, handlers) {


                let response = await fetch(`https://${this.domain}/api/websocket/stream`);
                let sessionKey = await response.text();
                console.log("Established new websocket session: ", sessionKey);
                let url = `wss://${this.domain}/video/${sessionKey}`;

                return this.connect(url, displayName, iconUrl, handlers);
            }
            async join(sessionKey, displayName, iconUrl, handlers) {
                let url = `wss://${this.domain}/video/${sessionKey}`;
                return this.connect(url, displayName, iconUrl, handlers);
            }

            async connect(url, displayName, iconUrl, handlers) {

                this.displayName = displayName;
                this.iconUrl = iconUrl || '';

                return new Promise(async (resolve, reject) => {
                    handlers = handlers || {};
                    handlers.onOpen = handlers.onOpen || this.websocket_onOpen.bind(this);
                    handlers.onMessage = handlers.onMessage || this.websocket_onMessage.bind(this);
                    handlers.onClose = handlers.onClose || this.websocket_onClose.bind(this);
                    handlers.onError = handlers.onError || this.websocket_onError.bind(this);
                    try {
                        if (this.socket != null) {
                            this.close();
                        }

                        this.socket = new WebSocket(url);

                        this.socket.onopen = (event) => { resolve(); handlers.onOpen(event); }
                        this.socket.onmessage = handlers.onMessage;
                        this.socket.onclose = handlers.onClose;
                        this.socket.onerror = handlers.onError;

                        window.addEventListener('beforeunload', () => {
                            this.socket.onclose = function () { }; // disable onclose handler first
                            this.socket.close();
                        }, { once: true });

                    }
                    catch (ex) {
                        console.error(ex);
                        reject();
                    }
                })
            }
            async send(message) {
                this.socket.send(message);
            }
            async close() {
                this.socket.close();
            }

            //handlers
            async websocket_onOpen(event) {
                console.log("[Websocket] Connection established");
            }
            async websocket_onMessage(event) {
                console.log(`[Websocket] Data received from server: ${event.data}`);
                let data = JSON.parse(event.data);

                // delegate event to specialized functions
                // dispatch event if it's unrelated to the websocket session (messages/notifications/etc)
                switch (socketMessageTypeMap[data.MessageType]) {
                    case 'Greeting':
                        let greetingValue = JSON.parse(data.Message);
                        console.log(greetingValue);
                        this.initSession(greetingValue);
                        let greetingEvent = new CustomEvent('greeting', { detail: greetingValue });
                        this.dispatchEvent(greetingEvent);
                        break;
                    case 'Introduction':
                        console.error('Client should never receive "Introduction" Message Type.');
                        return;
                    case 'Heartbeat':
                        console.log('[Websocket] Heartbeat received.');
                        // don't usually dispatch heartbeats, but I'm not utilizing them, either.
                        break;
                    case 'Properties':
                        let propertiesValue = JSON.parse(data.Message);
                        console.log(propertiesValue);
                        let propertiesEvent = new CustomEvent('properties', { detail: propertiesValue });
                        this.dispatchEvent(propertiesEvent);
                        break;
                    case 'StatusUpdates':
                        let statusUpdatesValue = JSON.parse(data.Message);
                        console.log(statusUpdatesValue);
                        let connectionUpdates = this.getConnectionUpdates(statusUpdatesValue);
                        if (connectionUpdates.length > 0) {
                            this.updatePeerStatus(connectionUpdates);
                            let peersEvent = new CustomEvent('peers', { detail: connectionUpdates });
                            this.dispatchEvent(peersEvent);
                        }
                        let otherUpdates = statusUpdatesValue.filter((item) => { return (item.Status.toLowerCase().indexOf('connect') == -1); });
                        if (otherUpdates.length > 0) {
                            let statusUpdatesEvent = new CustomEvent('statusupdates', { detail: otherUpdates });
                            this.dispatchEvent(statusUpdatesEvent);
                        }
                        break;
                    case 'Notifications':
                        console.log('[Websocket] Notifications received.');
                        let notificationsEvent = new CustomEvent('notifications', { detail: otherUpdates });
                        this.dispatchEvent(notificationsEvent);
                        break;
                    case 'Reaction':
                        console.log('[Websocket] Reaction received.');
                        let reactionEvent = new CustomEvent('reaction', { detail: data });
                        this.dispatchEvent(reactionEvent);
                        break;
                    case 'Text':
                    case 'FormattedText':
                    case 'Url':
                    case 'ByteArray':
                        console.log('[Websocket] Message received.');
                        let messageEvent = new CustomEvent('message', { detail: data });
                        this.dispatchEvent(messageEvent);
                        break;
                    case 'Unknown':
                    default:
                        console.error("[Websocket] Unknown Message Type: " + data.MessageType);
                        return;
                }
            }
            async websocket_onClose(event) {

                if (event.wasClean) {
                    console.log(`[Websocket] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
                } else {
                    // e.g. server process killed or network down
                    // event.code is usually 1006 in this case
                    console.log('[Websocket] Connection died');
                }
                this.socket = null;
                let messageEvent = new CustomEvent('close');
                this.dispatchEvent(messageEvent);
            }
            async websocket_onError(event) {

                console.error(`[Websocket] ${error.message}`);
            }


            //functionality
            initSession(greeting) {

                this.token = greeting.Token;
                this.hostToken = greeting.HostToken;

                this.updatePeers(greeting.Peers);

                this.makeIntroduction();

            }
            makeIntroduction() {

                let displayName = this.displayName || this.token.SocketId;
                this.token.DisplayName = displayName;
                this.token.IconUrl = '';

                console.log("Sending Introduction: ", this.token);
                let message = JSON.stringify(this.token);
                this.socket.send(JSON.stringify({ Type: 2, SenderId: this.token, Message: message }));
            }

            getConnectionUpdates(statusUpdates) {
                let connectionUpdates = [];
                for (let i = 0; i < statusUpdates.length; i++) {
                    let statusUpdate = statusUpdates[i];
                    if (statusUpdate.Status == 'connect') {
                        connectionUpdates.push(statusUpdate);
                    }
                    else if (statusUpdate.Status == 'disconnect') {
                        this.removePeers(statusUpdate.Peers);
                        connectionUpdates.push(statusUpdate);
                    }
                }

                return connectionUpdates;
            }

            updatePeerStatus(updates) {
                for (let i = 0; i < updates.length; i++) {
                    let update = updates[i];
                    if (update.status == 'disconnect') {
                        this.removePeers(update.Peers);
                        continue;
                    }
                    this.updatePeers(update.Peers);
                }
            }
            updatePeers(peers) {
                if (peers == null) {
                    return;
                }
                for (let i = 0; i < peers.length; i++) {
                    let peer = peers[i];
                    this.updatePeer(peer);
                }
            }
            updatePeer(peer) {
                this.peerTokens[peer.SocketId] = peer;
            }
            removePeers(peers) {
                if (peers == null) {
                    return;
                }
                for (let i = 0; i < peers.length; i++) {
                    let peer = peers[i];
                    this.removePeer(peer);
                }
            }
            removePeer(peer) {
                delete this.peerTokens[peer.SocketId];
            }
        }

        class VideoPeer {
            constructor() {
                this.peerConnection = null;
                this.token = null;
                this.$peer = null;
                this.stream = null;
            }

            addConnection(chat, id, configuration) {

                console.log('RTCPeerConnection configuration:', configuration);
                this.peerConnection = new RTCPeerConnection(configuration);
                this.peerConnection.addEventListener('track', chat.peerConnection_onTrack.bind(chat));
                //this.peerConnection.addEventListener('connectionstatechange', chat.peerConnection_onConnectionStateChange.bind(this));
                console.log('Created peer connection object peerConnection');
                this.peerConnection.addEventListener('icecandidate', (event) => {
                    if (event.candidate != null) {
                        //this.peerConnection.addIceCandidate(event.candidate);
                        chat.sendValue({ type: 'candidate', candidate: event.candidate }, null, id);
                    }
                });
                this.peerConnection.addEventListener('iceconnectionstatechange', (event) => {
                    console.log('ICE state change event: ', event);
                });

                // add local stream tracks to peer connection
                chat.localStream.getTracks().forEach(track => this.peerConnection.addTrack(track, chat.localStream));
                console.log('Added local stream to peerConnection');
            }

            setStream() {
                if (this.$peer == null) {
                    return;
                }

                this.$peer.$video.srcObject = this.stream;
                this.$peer.$video.play();
            }
        }
        class VideoChat {
            constructor($parentNode) {
                this.$parentNode = $parentNode;
                if (this.$parentNode == null || !(this.$parentNode instanceof HTMLElement)) {
                    throw new Error('$parentNode must be an instance of the HTMLElement type.')
                }

                this.configuration = {};
                this.chatSession = null;
                this.localStream = null;
                this.videoPeers = {};
                // this.rooms = []; // [enhancement]: implement multiple rooms, instead of just one well-known chatroom.

                // easy event forwarding
                let node = document.createTextNode(null);
                this.addEventListener = node.addEventListener.bind(node);
                this.removeEventListener = node.removeEventListener.bind(node);
                this.dispatchEvent = node.dispatchEvent.bind(node);

                // create interface
                this._createInterface();

                // state informtaion
                this.isHost = false;
                this._skippedIntro = false;// internal helper
                this._peerDescriptionIsSet = false;
            }
            _createInterface() {

                let template = document.getElementById('video-chat-ui');
                let templateContent = template.content;
                this.$parentNode.appendChild(templateContent.cloneNode(true));

                this.$videoPeers = document.getElementById('video-peers');
                this.$clientWebcam = document.getElementById('client-webcam');
                this.$videos = document.querySelector('.card.video-chat .videos');
                this.$videoToasts = document.getElementById('toasts');
                this.$videoDisplayName = document.getElementById('video-display-name');
                this.$getWebcamButton = document.getElementById('get-webcam-feed');
                this.$startVideoChatButton = document.getElementById('start-video-chat');
                this.$endVideoChatButton = document.getElementById('end-video-chat');
                this.$joinVideoChatButton = document.getElementById('join-video-chat');
                this.$leaveVideoChatButton = document.getElementById('leave-video-chat');
                this.$hostSessionKey = document.getElementById('host-session-key');
                this.$guestSessionKey = document.getElementById('guest-session-key');

                this.$getWebcamButton.addEventListener('click', this.getWebcam_onClick.bind(this));
                this.$startVideoChatButton.addEventListener('click', this.startVideoChat_onClick.bind(this));
                this.$endVideoChatButton.addEventListener('click', this.endVideoChat_onClick.bind(this));
                this.$joinVideoChatButton.addEventListener('click', this.joinVideoChat_onClick.bind(this));
                this.$leaveVideoChatButton.addEventListener('click', this.leaveVideoChat_onClick.bind(this));
            }

            // handlers
            chatSession_OnGreeting(event) {
                this.updateChatPeers();
                if (this.isHost == true) {
                    this.$hostSessionKey.value = event.detail.SessionKey;
                }
                else {
                    // send room request
                }
            }
            async chatSession_OnPeers(event) {

                let updates = event.detail;
                for (let i = 0; i < updates.length; i++) {
                    let update = updates[i];

                    for (let j = 0; j < update.Peers.length; j++) {
                        let peer = update.Peers[j];
                        let displayName = (peer.DisplayName == '') ? `[${peer.SocketId}]` : peer.DisplayName;
                        let peerIsHost = peer.SocketId == this.chatSession.hostToken.SocketId;
                        if (update.Status == 'connect') {

                            // create peer connection
                            let videoPeer = this.addPeer(peer.SocketId);
                            videoPeer.addConnection(this, peer.SocketId, this.configuration);

                            try {
                                // create offer
                                const offerOptions = {
                                    offerToReceiveAudio: 1,
                                    offerToReceiveVideo: 1
                                };

                                console.log('localPeerConnection createOffer start');
                                let offer = await videoPeer.peerConnection.createOffer(offerOptions);
                                //console.log(`Offer from peerConnection\n${this.peerOffer.sdp}`);

                                // set description
                                console.log('peerConnection setLocalDescription start');
                                try {
                                    await videoPeer.peerConnection.setLocalDescription(offer);
                                    console.log(`setLocalDescription complete`);
                                } catch (error) {
                                    console.log(`Failed to set session description: ${error.toString()}`);
                                }

                                // send offer to peer
                                let offerMessage = { type: 'offer', offer: offer };
                                this.sendValue(offerMessage, null, message.SenderId);
                            } catch (error) {
                                console.log(`Failed to create offer: ${error.toString()}`);
                            }
                        }
                        else if (update.Status == 'disconnect') {
                            let action = (peerIsHost == true) ? 'ended' : 'left';
                            let content = `<div>${displayName} has ${action} the chat.</div>`;
                            let $leaveMessage = this.showChatMessage(content);
                            $leaveMessage.classList.add('status');
                        }
                    }
                }

                this.updateChatPeers();
            }
            async chatSession_OnMessage(event) {

                console.log(event);

                let message = event.detail;
                let data = JSON.parse(message.Message);
                if (message.SenderId != this.chatSession.token.SocketId) {
                    if (data.type == 'candidate') {
                        try {
                            let videoPeer = this.getPeer(message.SenderId);
                            if (videoPeer != null) {
                                videoPeer.peerConnection.addIceCandidate(data.candidate);
                            }
                        } catch (error) {
                            console.log(`Failed to add ice candidate: ${error.toString()}`);
                        }
                    }
                    else if (data.type == 'offer') {

                        let videoPeer = this.getPeer(message.SenderId);
                        if (videoPeer == null) {
                            videoPeer = this.addPeer(message.SenderId);
                            videoPeer.addConnection(this, message.SenderId, data.configuration);
                        }

                        try {
                            console.log('setRemoteDescription start');
                            await videoPeer.peerConnection.setRemoteDescription(data.offer);
                            console.log(`setRemoteDescription complete`);

                        } catch (error) {
                            console.log(`Failed to set remote session description: ${error.toString()}`);
                        }

                        // create answer
                        console.log('createAnswer start');
                        try {
                            const answer = await videoPeer.peerConnection.createAnswer();
                            console.log('answer created');

                            videoPeer.peerConnection.setLocalDescription(answer);
                            videoPeer.$peer = this.createPeerElement(videoPeer.peerConnection);
                            this.$videos.appendChild(videoPeer.$peer);
                            videoPeer.setStream();

                            let answerMessage = { type: 'answer', answer: answer };
                            this.sendValue(answerMessage);

                            let content = `<div>${this.chatSession.peerTokens[message.SenderId].DisplayName} has joined the chat.</div>`;
                            let $joinMessage = this.showChatMessage(content);
                            $joinMessage.classList.add('status');

                        } catch (error) {
                            console.error(error);
                        }
                    }
                    else if (data.type == 'answer') {
                        try {
                            let videoPeer = this.getPeer(message.SenderId);
                            if (videoPeer != null) {
                                console.log('setRemoteDescription start');
                                await videoPeer.peerConnection.setRemoteDescription(data.answer);
                                console.log(`setRemoteDescription complete`);

                                videoPeer.$peer = this.createPeerElement(videoPeer.peerConnection);
                                this.$videos.appendChild(videoPeer.$peer);
                                videoPeer.setStream();
                            }
                        } catch (error) {
                            console.log(`Failed to set remote session description: ${error.toString()}`);
                        }
                    }
                }
            }
            chatSession_OnStatusUpdates(event) {
                if (localPeerDescriptionSet == true && event.detail.Status == 'introduction') {
                    console.log("Sending to server");
                    // send offer through signaling channel
                    //chatSession.send(JSON.stringify({ Message: localPeerOffer }));
                }
            }
            chatSession_OnClose(event) {
                if (this.chatSession.ending == true) {
                    let action = (this.chatSession.token.SocketId == this.chatSession.hostToken.SocketId) ? 'ended' : 'left';
                    this.showChatMessage(`[You have ${action} the chat session.]`);
                }
                else {
                    this.showChatMessage('[The chat session has been ended.]')
                }
                this.chatSession = null;
            }

            async getWebcam_onClick(event) {
                console.log('Requesting local stream');
                this.$getWebcamButton.disabled = true;
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: { width: 1280, height: 720 } });
                    console.log('Received local stream');
                    this.$clientWebcam.srcObject = stream;
                    this.localStream = stream;
                    this.$getWebcamButton.disabled = false;
                }
                catch (exception) {
                    console.error(`getUserMedia() error: ${exception.name}`);
                }
            }

            async startVideoChat_onClick(event) {
                this.host();
            }
            async endVideoChat_onClick(event) {
                if (this.isHost == false) {
                    return;
                }
            }

            async joinVideoChat_onClick(event) {
                this.join(this.$guestSessionKey.value);
            }
            async leaveVideoChat_onClick(event) {

            }

            peerConnection_onTrack(event) {
                //console.log(event.currentTarget);
                let videoPeer;
                for (let property in this.videoPeers) {
                    if (this.videoPeers.hasOwnProperty(property)) {
                        if (this.videoPeers[property].peerConnection == event.currentTarget) {
                            videoPeer = this.videoPeers[property];
                        }
                    }
                }
                videoPeer.stream = event.streams[0];
                event.track.onunmute = () => {
                    console.log('track unmuted');
                    videoPeer.setStream();
                }
            }
            peerConnection_onConnectionStateChange(event) {
                console.log("[STATE]", event);
            }

            // functionality
            async host() {
                if (this.localStream == null) {
                    console.error("Cannot create a video chat without source media stream.");
                    return;
                }

                if (this.chatSession != null) {
                    console.error('Session is already active. End the session before starting a new one.');
                    return;
                }

                // set UI state
                this.$clientWebcam.disabled = true;
                this.$endVideoChatButton.disabled = false;
                this.resetChat();

                // get signaling session
                this.chatSession = new WebsocketSession();
                this.chatSession.addEventListener('greeting', this.chatSession_OnGreeting.bind(this));
                this.chatSession.addEventListener('peers', this.chatSession_OnPeers.bind(this));
                this.chatSession.addEventListener('message', this.chatSession_OnMessage.bind(this));
                this.chatSession.addEventListener('statusupdates', this.chatSession_OnStatusUpdates.bind(this));
                this.chatSession.addEventListener('close', this.chatSession_OnClose.bind(this));
                await this.chatSession.host(this.$videoDisplayName.value);
                this.isHost = true;
            }
            async join(sessionKey) {
                if (this.localStream == null) {
                    console.error("Cannot create a video chat without source media stream.");
                    return;
                }

                if (this.chatSession != null) {
                    console.error('Session is already active. End the session before starting a new one.');
                    return;
                }

                // set UI state
                this.$clientWebcam.disabled = true;
                this.$endVideoChatButton.disabled = false;
                this.resetChat();

                // get signaling session
                this.chatSession = new WebsocketSession();
                this.chatSession.addEventListener('greeting', this.chatSession_OnGreeting.bind(this));
                this.chatSession.addEventListener('peers', this.chatSession_OnPeers.bind(this));
                this.chatSession.addEventListener('message', this.chatSession_OnMessage.bind(this));
                this.chatSession.addEventListener('statusupdates', this.chatSession_OnStatusUpdates.bind(this));
                this.chatSession.addEventListener('close', this.chatSession_OnClose.bind(this));
                await this.chatSession.join(sessionKey, this.$videoDisplayName.value);
            }

            sendValue(value, type, recipients) {
                this.sendMessage(JSON.stringify(value), type, recipients);
            }
            sendMessage(message, type, recipients) {
                type = type || 8;
                if (recipients != null) {
                    if (!Array.isArray(recipients)) {
                        recipients = [recipients];
                    }
                }
                this.chatSession.send(JSON.stringify({ Type: type, SenderId: this.token, Message: message, Recipients: recipients }))
            }

            resetChat() {
                this.clearChatHistory();
                this.clearChatParticipants();
            }
            clearChatHistory() {
                while (this.$videoToasts.lastChild) {
                    this.$videoToasts.lastChild.remove();
                }
            }
            clearChatParticipants() {
                while (this.$videoPeers.lastChild) {
                    this.$videoPeers.lastChild.remove();
                }
            }
            updateChatPeers() {
                this.clearChatParticipants();

                for (let property in this.chatSession.peerTokens) {

                    let peer = this.chatSession.peerTokens[property];
                    let displayName = (peer.DisplayName == '') ? `[${peer.SocketId}]` : peer.DisplayName;
                    let $peer = document.createElement('li');
                    $peer.classList.add('peer');
                    if (peer == this.chatSession.HostToken) {
                        $peer.classList.add('host');
                    }
                    $peer.textContent = displayName;
                    this.$videoPeers.appendChild($peer);
                }
            }
            showChatMessage(messageData) {
                let content;
                if (Object.prototype.toString.call(messageData) === '[object String]') {
                    content = `${messageData}`;
                }
                else {
                    let peer = (messageData.SenderId == this.chatSession.token.SocketId) ? this.chatSession.token : this.chatSession.peerTokens[messageData.SenderId];
                    if (peer == null) {
                        console.error('Unknown Participant. Socket ID: ' + messageData.SenderId);
                        return;
                    }
                    content = `<header>
                                                        <img class="icon" src="${peer.IconUrl || ''}" />
                                                        <span class="name">${peer.DisplayName || ''}</span>
                                                    </header>
                                                    <div>${messageData.Message}</div>`;
                }

                let $message = document.createElement('li');
                $message.classList.add('toast');
                $message.innerHTML = content;

                this.$videoToasts.appendChild($message);
                return $message;
            }

            addPeer(id) {
                let videoPeer = new VideoPeer();
                videoPeer.token = this.chatSession.peerTokens[id];
                this.videoPeers[id] = videoPeer;

                return videoPeer;
            }
            getPeer(socketId) {
                for (let property in this.videoPeers) {
                    if (this.videoPeers.hasOwnProperty(property)) {
                        if (property == socketId) {
                            return this.videoPeers[property];
                        }
                    }
                }
                return null;
            }
            createPeerElement(peerConnection) {
                let $peer = document.createElement('li');
                $peer.classList.add('peer');
                $peer.innerHTML = `<video width="800" height="450"></video>`
                $peer.$video = $peer.querySelector('video');
                $peer.$video.autoplay = true;
                $peer.peerConnection = peerConnection;
                return $peer;
            }
            getPeerElement(peerConnection) {
                let $peer = null;
                let $elements = this.$videos.querySelectorAll('.peer');
                [].map.call($elements, ($element) => {
                    if ($element.peerConnection == peerConnection) {
                        $peer = $element;
                    }
                });
                return $peer;
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {

            // file upload
            async function websocketTest_onClick(event) {
                let totalBytes = $form['uploadfile'].files[0].size;
                $progressTotal.textContent = totalBytes;

                if (progressSession != null) {
                    console.error('Session is already active. End the session before starting a new one.');
                    return;
                }

                clearProgressReport();

                progressSession = new WebsocketSession();
                progressSession.addEventListener('statusupdates', progressSession_OnStatusUpdates);
                progressSession.addEventListener('close', progressSession_OnClose);

                let sessionResponse = await fetch(`https://${apiDomain}/api/websocket/progress/${totalBytes}`);
                let sessionKey = await sessionResponse.text();
                console.log("Established new websocket session: ", sessionKey);
                let url = `wss://${apiDomain}/progress/${sessionKey}`;

                await progressSession.connect(url);

                let options =
                {
                    method: "POST",
                    body: new FormData($form)
                };
                fetch(`https://${apiDomain}/api/streaming/progress/${sessionKey}`, options);
            }
            function progressSession_OnStatusUpdates(event) {
                for (let i = 0; i < event.detail.length; i++) {
                    updateProgress(event.detail[i]);
                }
            }
            function progressSession_OnClose(event) {
                showProgressMessage('[File Upload Complete]');
                progressSession = null;
            }

            function clearProgressReport() {
                $progressPercentage.value = 0;
                showProgressMessage('');
            }
            function updateProgress(update) {
                if (update.Status != 'progress') {
                    return;
                }
                $progressPercentage.value = (update.Progress.UnitsCompleted / update.Progress.UnitTotal) * 100;
                showProgressMessage(update.Progress.UnitsCompleted);
            }
            function showProgressMessage(message) {
                $progressValue.textContent = message;
            }

            var $form = document.querySelector('form');
            var $websocketTest = document.querySelector('.websocket-test');
            var $progressValue = document.querySelector('span.progress-value');
            var $progressTotal = document.querySelector('span.progress-total');
            var $progressPercentage = document.querySelector('progress');
            $websocketTest.addEventListener('click', websocketTest_onClick);



            // chat
            async function startChat_onClick(event) {
                if (chatSession != null) {
                    console.error('Session is already active. End the session before starting a new one.');
                    return;
                }

                clearChatHistory();
                clearChatParticipants();

                chatSession = new WebsocketSession();
                chatSession.addEventListener('greeting', chatSession_OnGreeting);
                chatSession.addEventListener('peers', chatSession_OnPeers);
                chatSession.addEventListener('message', chatSession_OnMessage);
                chatSession.addEventListener('close', chatSession_OnClose);
                await chatSession.host($chatDisplayName.value);
            }
            async function sendMessage_onClick(event) {
                if (chatSession == null) {
                    console.error("No session has been started.");
                    return;
                }

                console.log("Sending to server");
                addChatMessage({ SenderId: chatSession.token.SocketId, Message: $message.value });
                chatSession.send(JSON.stringify({ Message: $message.value }));
            }
            async function endChat_onClick(event) {
                if (chatSession == null) {
                    return;
                }
                chatSession.ending = true;
                await chatSession.close();
            }

            function chatSession_OnGreeting(event) {
                $chatSessionKey.value = event.detail.SessionKey;
                updateChatPeers();
            }
            function chatSession_OnPeers(event) {
                updateChatPeers();

                // show messages
                let updates = event.detail;
                for (let i = 0; i < updates.length; i++) {
                    let update = updates[i];
                    for (let j = 0; j < update.Peers.length; j++) {
                        let peer = update.Peers[j];
                        let displayName = (peer.DisplayName == '') ? `[${peer.SocketId}]` : peer.DisplayName;
                        let isHost = peer.SocketId == chatSession.hostToken.SocketId;
                        if (update.Status == 'connect' && isHost == false) {
                            let content = `<div>${displayName} has joined the chat.</div>`;
                            let $joinMessage = addChatMessage(content);
                            $joinMessage.classList.add('status');
                        }
                        else if (update.Status == 'disconnect') {
                            let action = (isHost == true) ? 'ended' : 'left';
                            let content = `<div>${displayName} has ${action} the chat.</div>`;
                            let $leaveMessage = addChatMessage(content);
                            $leaveMessage.classList.add('status');
                        }
                    }
                }
            }
            function chatSession_OnMessage(event) {
                addChatMessage(event.detail);
            }
            function chatSession_OnClose(event) {
                if (chatSession.ending == true) {
                    let action = (chatSession.token.SocketId == chatSession.hostToken.SocketId) ? 'ended' : 'left';
                    addChatMessage(`[You have ${action} the chat session.]`);
                }
                else {
                    addChatMessage('[The chat session has been ended.]')
                }
                chatSession = null;
            }

            function clearChatHistory() {
                while ($messageHistory.lastChild) {
                    $messageHistory.lastChild.remove();
                }
            }
            function clearChatParticipants() {
                while ($messagingParticipants.lastChild) {
                    $messagingParticipants.lastChild.remove();
                }
            }
            function updateChatPeers() {
                clearChatParticipants();

                for (let property in chatSession.peerTokens) {

                    let peer = chatSession.peerTokens[property];
                    let displayName = (peer.DisplayName == '') ? `[${peer.SocketId}]` : peer.DisplayName;
                    let $peer = document.createElement('li');
                    $peer.classList.add('peer');
                    if (peer == chatSession.HostToken) {
                        $peer.classList.add('host');
                    }
                    $peer.textContent = displayName;
                    $messagingParticipants.appendChild($peer);
                }
            }
            function addChatMessage(messageData) {
                let content;
                if (Object.prototype.toString.call(messageData) === '[object String]') {
                    content = `${messageData}`;
                }
                else {
                    let peer = (messageData.SenderId == chatSession.token.SocketId) ? chatSession.token : chatSession.peerTokens[messageData.SenderId];
                    if (peer == null) {
                        console.error('Unknown Participant. Socket ID: ' + messageData.SenderId);
                        return;
                    }
                    content = `<header>
                                                    <img class="icon" src="${peer.IconUrl || ''}" />
                                                    <span class="name">${peer.DisplayName || ''}</span>
                                                </header>
                                                <div>${messageData.Message}</div>`;
                }

                let $message = document.createElement('li');
                $message.classList.add('message');
                $message.innerHTML = content;

                $messageHistory.appendChild($message);
                return $message;
            }

            var $chatSessionKey = document.getElementById('chat-session-key');
            var $chatDisplayName = document.getElementById('chat-display-name');
            var $startChat = document.getElementById('start-chat');
            var $endChat = document.getElementById('end-chat');
            var $messagingParticipants = document.getElementById('messaging-participants');
            var $messageHistory = document.getElementById('message-history');
            var $message = document.getElementById('message');
            var $sendMessageButton = document.getElementById('send-message');

            $startChat.addEventListener('click', startChat_onClick);
            $endChat.addEventListener('click', endChat_onClick);
            $sendMessageButton.addEventListener('click', sendMessage_onClick);

            // video
            new VideoChat(document.querySelector('.card.video-chat'));
        });
    </script>
</body>
</html>