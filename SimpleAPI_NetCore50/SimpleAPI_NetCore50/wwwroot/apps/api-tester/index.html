<html>
<body>
    <h1>API Tester</h1>
    <h3>This page is for testing non-REST functionality, including file streaming, websocket, and WebRTC sessions.</h3>
    <h3>For testing any standard REST endpoints, please use the OpenAPI route (this can be set as the default in launchsettings.json)</h3>
    <div class="card">
        <form enctype="multipart/form-data" method="post">
            <dl>
                <dt>
                    <label>File</label>
                </dt>
                <dd>
                    <input name="uploadfile" type="file">
                </dd>
            </dl>
        </form>
        <button class="websocket-test" type="button">Test Websocket</button>
        <div>
            <span>Progress:</span><span class="progress-value"></span><span>/</span><span class="progress-total"></span>
        </div>
        <div>
            <progress id="progress-percent" min="0" max="100" step="1" value="0"></progress>
        </div>
    </div>
    <div class="card">
        <header>
            <h2>Messaging</h2>
            <div>
                <h4>Participants</h4>
                <ul id="messaging-participants"></ul>
            </div>
            <div>
                <span>
                    <span class="title">Display Name:</span>
                    <input id="chat-display-name" type="text" value="Host" />
                </span>
                <button id="start-chat" type="button">Start Chat</button>
                <button id="end-chat" type="button">End Chat</button>
            </div>
            <div>
                <span class="title">Session Key:</span>
                <input id="chat-session-key" type="text" placeholder="Start a chat session to generate a key." disabled />
            </div>
        </header>
        <ul id="message-history"></ul>
        <div>
            <textarea id="message"></textarea>
            <button id="send-message" type="button">Send</button>
        </div>
    </div>
    <div class="card">
        <video width="1280" height="720" id="client-webcam"></video>
        <ul class="remote-webcams"></ul>
        <div>
            <button id="get-webcam-feed" type="button">Get Webcam Feed</button>
            <button id="start-video-chat" type="button">Start Stream</button>
            <button id="end-video-chat" type="button">End Stream</button>
        </div>
    </div>
    <script>
        var apiDomain = '192.168.254.12';
        var chatSession = null;
        var videoSignalingSession = null;

        var signalingSocket = null;
        var localStream = null;
        var localPeerConnection = null;
        var remotePeerConnections = [];

        const socketMessageTypeMap =
            [
                'Unknown', // error checking
                'Greeting', // sending the initial session token and host token
                'Introduction', // for gaining access to channels / providing user data like name/profile pic
                'Heartbeat', // keep-alive signals
                'Properties', // for properties like the participants list or the host id
                'StatusUpdates', // users joined/users left/users are typing/users are asleep/etc
                'Notifications', // relationship added/username tagged/ etc
                'Reaction', // reaction to a message
                'Text', // Text message
                'FormattedText', // Text message that should be handled with special cases
                'Url', // images/videos/audio/media/files anything linked via url
                'ByteArray' // binary data
            ];
        class WebsocketSession {
            constructor() {
                this.domain = '192.168.254.12';

                this.socket = null;
                this.token = null;
                this.hostToken = null;
                this.peerTokens = {};
                this.offer = null;

                let node = document.createTextNode(null);
                this.addEventListener = node.addEventListener.bind(node);
                this.removeEventListener = node.removeEventListener.bind(node);
                this.dispatchEvent = node.dispatchEvent.bind(node);
            }

            async host(displayName, iconUrl, handlers) {


                let response = await fetch(`https://${this.domain}:5001/api/websocket/stream`);
                let sessionKey = await response.text();
                console.log("Established new websocket session: ", sessionKey);
                let url = `wss://${this.domain}:5001/video/${sessionKey}`;

                return this.connect(url, displayName, iconUrl, handlers);
            }
            async join(sessionKey, displayName, iconUrl, handlers) {
                let url = `wss://${this.domain}:5001/video/${sessionKey}`;
                return this.connect(url, displayName, iconUrl, handlers);
            }

            async connect(url, displayName, iconUrl, handlers) {

                this.displayName = displayName;
                this.iconUrl = iconUrl || '';

                return new Promise(async (resolve, reject) => {
                    handlers = handlers || {};
                    handlers.onOpen = handlers.onOpen || this.websocket_onOpen.bind(this);
                    handlers.onMessage = handlers.onMessage || this.websocket_onMessage.bind(this);
                    handlers.onClose = handlers.onClose || this.websocket_onClose.bind(this);
                    handlers.onError = handlers.onError || this.websocket_onError.bind(this);
                    try {
                        if (this.socket != null) {
                            this.close();
                        }

                        this.socket = new WebSocket(url);

                        this.socket.onopen = (event) => { resolve(); handlers.onOpen(event); }
                        this.socket.onmessage = handlers.onMessage;
                        this.socket.onclose = handlers.onClose;
                        this.socket.onerror = handlers.onError;

                        window.addEventListener('beforeunload', () => {
                            this.socket.onclose = function () { }; // disable onclose handler first
                            this.socket.close();
                        }, { once: true });

                    }
                    catch (ex) {
                        console.error(ex);
                        reject();
                    }
                })
            }
            async send(message) {
                this.socket.send(message);
            }
            async close() {
                this.socket.close();
            }

            //handlers
            async websocket_onOpen(event) {
                console.log("[Websocket] Connection established");
            }
            async websocket_onMessage(event) {
                console.log(`[Websocket] Data received from server: ${event.data}`);
                let data = JSON.parse(event.data);

                // delegate event to specialized functions
                // dispatch event if it's unrelated to the websocket session (messages/notifications/etc)
                switch (socketMessageTypeMap[data.MessageType]) {
                    case 'Greeting':
                        let greetingValue = JSON.parse(data.Message);
                        console.log(greetingValue);
                        this.initSession(greetingValue);
                        let greetingEvent = new CustomEvent('greeting', { detail: greetingValue });
                        this.dispatchEvent(greetingEvent);
                        break;
                    case 'Introduction':
                        console.error('Client should never receive "Introduction" Message Type.');
                        return;
                    case 'Heartbeat':
                        console.log('[Websocket] Heartbeat received.');
                        // don't usually dispatch heartbeats, but I'm not utilizing them, either.
                        break;
                    case 'Properties':
                        let propertiesValue = JSON.parse(data.Message);
                        console.log(propertiesValue);
                        let propertiesEvent = new CustomEvent('properties', { detail: propertiesValue });
                        this.dispatchEvent(propertiesEvent);
                        break;
                    case 'StatusUpdates':
                        let statusUpdatesValue = JSON.parse(data.Message);
                        console.log(statusUpdatesValue);
                        let connectionUpdates = this.getConnectionUpdates(statusUpdatesValue);
                        if (connectionUpdates.length > 0) {
                            this.updatePeerStatus(connectionUpdates);
                            let peersEvent = new CustomEvent('peers', { detail: connectionUpdates });
                            this.dispatchEvent(peersEvent);
                        }
                        let otherUpdates = statusUpdatesValue.filter((item) => { return (item.Status.toLowerCase().indexOf('connect') == -1); });
                        if (otherUpdates.length > 0) {
                            let statusUpdatesEvent = new CustomEvent('statusupdates', { detail: otherUpdates });
                            this.dispatchEvent(statusUpdatesEvent);
                        }
                        break;
                    case 'Notifications':
                        console.log('[Websocket] Notifications received.');
                        let notificationsEvent = new CustomEvent('notifications', { detail: otherUpdates });
                        this.dispatchEvent(notificationsEvent);
                        break;
                    case 'Reaction':
                        console.log('[Websocket] Reaction received.');
                        let reactionEvent = new CustomEvent('reaction', { detail: data });
                        this.dispatchEvent(reactionEvent);
                        break;
                    case 'Text':
                    case 'FormattedText':
                    case 'Url':
                    case 'ByteArray':
                        console.log('[Websocket] Message received.');
                        let messageEvent = new CustomEvent('message', { detail: data });
                        this.dispatchEvent(messageEvent);
                        break;
                    case 'Unknown':
                    default:
                        console.error("[Websocket] Unknown Message Type: " + data.MessageType);
                        return;
                }
            }
            async websocket_onClose(event) {

                if (event.wasClean) {
                    console.log(`[Websocket] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
                } else {
                    // e.g. server process killed or network down
                    // event.code is usually 1006 in this case
                    console.log('[Websocket] Connection died');
                }
                this.socket = null;
                let messageEvent = new CustomEvent('close');
                this.dispatchEvent(messageEvent);
            }
            async websocket_onError(event) {

                console.error(`[Websocket] ${error.message}`);
            }


            //functionality
            initSession(greeting) {

                this.token = greeting.Token;
                this.hostToken = greeting.HostToken;

                this.updatePeers(greeting.Peers);

                this.makeIntroduction();

            }
            makeIntroduction() {

                let displayName = this.displayName || this.token.SocketId;
                this.token.DisplayName = displayName;
                this.token.IconUrl = '';

                console.log("Sending Introduction: ", this.token);
                let message = JSON.stringify(this.token);
                this.socket.send(JSON.stringify({ Type: 2, SenderId: this.token, Message: message }));
            }

            getConnectionUpdates(statusUpdates) {
                let connectionUpdates = [];
                for (let i = 0; i < statusUpdates.length; i++) {
                    let statusUpdate = statusUpdates[i];
                    if (statusUpdate.Status == 'connect') {
                        connectionUpdates.push(statusUpdate);
                    }
                    else if (statusUpdate.Status == 'disconnect') {
                        this.removePeers(statusUpdate.Peers);
                        connectionUpdates.push(statusUpdate);
                    }
                }

                return connectionUpdates;
            }

            updatePeerStatus(updates) {
                for (let i = 0; i < updates.length; i++) {
                    let update = updates[i];
                    if (update.status == 'disconnect') {
                        this.removePeers(update.Peers);
                        continue;
                    }
                    this.updatePeers(update.Peers);
                }
            }
            updatePeers(peers) {
                if (peers == null) {
                    return;
                }
                for (let i = 0; i < peers.length; i++) {
                    let peer = peers[i];
                    this.updatePeer(peer);
                }
            }
            updatePeer(peer) {
                this.peerTokens[peer.SocketId] = peer;
            }
            removePeers(peers) {
                if (peers == null) {
                    return;
                }
                for (let i = 0; i < peers.length; i++) {
                    let peer = peers[i];
                    this.removePeer(peer);
                }
            }
            removePeer(peer) {
                delete this.peerTokens[peer.SocketId];
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {

            async function websocketTest_onClick(event) {
                let totalBytes = $form['uploadfile'].files[0].size;
                $progressTotal.textContent = totalBytes;

                const response = await fetch(`https://${apiDomain}:5001/api/websocket/progress/${totalBytes}`);
                try {
                    let sessionKey = await response.text();
                    console.log(sessionKey);

                    let socket = new WebSocket(`wss://${apiDomain}:5001/progress/${sessionKey}`);

                    socket.onopen = function (e) {
                        console.log("[open] Connection established");
                        console.log("Sending to server");
                        socket.send("Handshake");
                    };

                    socket.onmessage = function (event) {
                        console.log(`[message] Data received from server: ${event.data}`);
                        let data = JSON.parse(event.data);
                        console.log(data);
                        $progressValue.textContent = data.UnitsCompleted;
                        $progressPercentage.value = (data.UnitsCompleted / data.UnitTotal) * 100;
                    };

                    socket.onclose = function (event) {
                        if (event.wasClean) {
                            console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
                        } else {
                            // e.g. server process killed or network down
                            // event.code is usually 1006 in this case
                            console.log('[close] Connection died');
                        }
                    };

                    socket.onerror = function (error) {
                        console.log(`[error] ${error.message}`);
                    };

                    window.addEventListener('beforeunload', () => {
                        socket.onclose = function () { }; // disable onclose handler first
                        socket.close();
                    }, { once: true });

                    let options =
                    {
                        method: "POST",
                        body: new FormData($form)
                    };

                    const response2 = await fetch(`https://${apiDomain}:5001/api/streaming/progress/${sessionKey}`, options);
                    if (!response2.ok) {
                        try {
                            let result1 = await response2.text();
                            console.log(result1)

                        } catch (ex) { console.error(ex); }
                    }
                    else {
                        console.log(await response2.json());
                    }

                } catch (ex) { console.error(ex); }
            }





            async function startChat_onClick(event) {
                if (chatSession != null) {
                    console.error('Session is already active. End the session before starting a new one.');
                    return;
                }

                clearChatHistory();
                clearChatParticipants();

                chatSession = new WebsocketSession();
                chatSession.addEventListener('greeting', chatSession_OnGreeting);
                chatSession.addEventListener('peers', chatSession_OnPeers);
                chatSession.addEventListener('message', chatSession_OnMessage);
                chatSession.addEventListener('close', chatSession_OnClose);
                await chatSession.host($chatDisplayName.value);
            }

            async function sendMessage_onClick(event) {
                if (chatSession == null) {
                    console.error("No session has been started.");
                    return;
                }

                console.log("Sending to server");
                addChatMessage({ SenderId: chatSession.token.SocketId, Message: $message.value });
                chatSession.send(JSON.stringify({ Message: $message.value }));
            }

            async function endChat_onClick(event) {
                if (chatSession == null) {
                    return;
                }
                chatSession.ending = true;
                await chatSession.close();
            }


            function clearChatHistory() {
                while ($messageHistory.lastChild) {
                    $messageHistory.lastChild.remove();
                }
            }
            function clearChatParticipants() {
                while ($messagingParticipants.lastChild) {
                    $messagingParticipants.lastChild.remove();
                }
            }
            function updateChatPeers() {
                clearChatParticipants();

                for (let property in chatSession.peerTokens) {

                    let peer = chatSession.peerTokens[property];
                    let displayName = (peer.DisplayName == '') ? `[${peer.SocketId}]` : peer.DisplayName;
                    let $peer = document.createElement('li');
                    $peer.classList.add('peer');
                    if (peer == chatSession.HostToken) {
                        $peer.classList.add('host');
                    }
                    $peer.textContent = displayName;
                    $messagingParticipants.appendChild($peer);
                }
            }
            function addChatMessage(messageData) {
                let content;
                if (Object.prototype.toString.call(messageData) === '[object String]') {
                    content = `${messageData}`;
                }
                else {
                    let peer = (messageData.SenderId == chatSession.token.SocketId) ? chatSession.token : chatSession.peerTokens[messageData.SenderId];
                    if (peer == null) {
                        console.error('Unknown Participant. Socket ID: ' + messageData.SenderId);
                        return;
                    }
                    content = `<header>
                                    <img class="icon" src="${peer.IconUrl || ''}" />
                                    <span class="name">${peer.DisplayName || ''}</span>
                                </header>
                                <div>${messageData.Message}</div>`;
                }

                let $message = document.createElement('li');
                $message.classList.add('message');
                $message.innerHTML = content;

                $messageHistory.appendChild($message);
                return $message;
            }

            function chatSession_OnGreeting(event) {
                $chatSessionKey.value = event.detail.SessionKey;
                updateChatPeers();
            }
            function chatSession_OnPeers(event) {
                updateChatPeers();

                // show messages
                let updates = event.detail;
                for (let i = 0; i < updates.length; i++) {
                    let update = updates[i];
                    for (let j = 0; j < update.Peers.length; j++) {
                        let peer = update.Peers[j];
                        let displayName = (peer.DisplayName == '') ? `[${peer.SocketId}]` : peer.DisplayName;
                        let isHost = peer.SocketId == chatSession.hostToken.SocketId;
                        if (update.Status == 'connect' && isHost == false) {
                            let content = `<div>${displayName} has joined the chat.</div>`;
                            let $joinMessage = addChatMessage(content);
                            $joinMessage.classList.add('status');
                        }
                        else if (update.Status == 'disconnect') {
                            let action = (isHost == true) ? 'ended' : 'left';
                            let content = `<div>${displayName} has ${action} the chat.</div>`;
                            let $leaveMessage = addChatMessage(content);
                            $leaveMessage.classList.add('status');
                        }
                    }
                }
            }
            function chatSession_OnStatusUpdates(event) {
                addChatMessage(event.detail);
            }
            function chatSession_OnMessage(event) {
                addChatMessage(event.detail);
            }
            function chatSession_OnClose(event) {
                if (chatSession.ending == true) {
                    let action = (chatSession.token.SocketId == chatSession.hostToken.SocketId) ? 'ended' : 'left';
                    addChatMessage(`[You have ${action} the chat session.]`);
                }
                else {
                    addChatMessage('[The chat session has been ended.]')
                }
                chatSession = null;
            }





            async function getWebcam_onClick(event) {
                console.log('Requesting local stream');
                $getWebcamButton.disabled = true;
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                    console.log('Received local stream');
                    $clientWebcam.srcObject = stream;
                    localStream = stream;
                    $getWebcamButton.disabled = false;
                }
                catch (exception) {
                    console.error(`getUserMedia() error: ${exception.name}`);
                }
            }

            async function startVideoChat_onClick(event) {

                if (localStream == null) {
                    console.error("Cannot create a video chat without source media stream.");
                    return;
                }

                await getSignalingSocket();
                // collect stream
                // create offer

                //onmessage
                // if type == participant
                //      send offer




                $clientWebcam.disabled = true;
                $endVideoChatButton.disabled = false;
                console.log('Starting stream');
                startTime = window.performance.now();
                const videoTracks = localStream.getVideoTracks();
                const audioTracks = localStream.getAudioTracks();
                if (videoTracks.length > 0) {
                    console.log(`Using video device: ${videoTracks[0].label}`);
                }
                if (audioTracks.length > 0) {
                    console.log(`Using audio device: ${audioTracks[0].label}`);
                }


                console.log('RTCPeerConnection configuration:', {});
                localPeerConnection = new RTCPeerConnection({});
                console.log('Created local peer connection object localPeerConnection');
                localPeerConnection.addEventListener('icecandidate', e => onIceCandidate(localPeerConnection, e));
                localPeerConnection.addEventListener('iceconnectionstatechange', e => onIceStateChange(localPeerConnection, e));

                localStream.getTracks().forEach(track => localPeerConnection.addTrack(track, localStream));
                console.log('Added local stream to localPeerConnection');

                try {
                    const offerOptions = {
                        offerToReceiveAudio: 1,
                        offerToReceiveVideo: 1
                    };

                    console.log('localPeerConnection createOffer start');
                    const offer = await localPeerConnection.createOffer(offerOptions);
                    await onCreateOfferSuccess(offer);
                } catch (e) {
                    onCreateSessionDescriptionError(e);
                }

            }

            async function endVideoChat_onClick(event) {

            }

            async function getSignalingSocket() {
                if (signalingSocket != null) {
                    return;
                }

                let response = await fetch(`https://${apiDomain}:5001/api/websocket/stream`);

                try {
                    let sessionKey = await response.text();
                    //$chatSessionKey.value = sessionKey;
                    console.log("Established new signaling session: ", sessionKey);

                    signalingSocket = new WebSocket(`wss://${apiDomain}:5001/video/${sessionKey}`);

                    signalingSocket.onopen = function (e) {
                        console.log("[open] Connection established");
                        console.log(e);
                    };

                    signalingSocket.onmessage = function (event) {
                        console.log(`[message] Data received from server: ${event.data}`);
                        let data = JSON.parse(event.data);

                        if (data.MessageType == 1) {
                            let value = JSON.parse(data.Message);
                            console.log(value);
                            initChat(value);
                        }
                        else if (data.MessageType == 3) {
                            let value = JSON.parse(data.Message);
                            console.log(value);
                            updateParticipant(value);
                            updateParticipants();
                        }
                        else if (data.MessageType == 5) {
                            let value = JSON.parse(data.Message);
                            console.log(value);
                            addChatUpdate(value.status, value.peer);
                        }
                        else if (data.MessageType == 8) {
                            addChatMessage(data);
                        }
                        console.log(data);
                    };

                    signalingSocket.onclose = function (event) {
                        if (event.wasClean) {
                            console.log(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);
                        } else {
                            // e.g. server process killed or network down
                            // event.code is usually 1006 in this case
                            console.log('[close] Connection died');
                        }
                        signalingSocket = null;
                    };

                    signalingSocket.onerror = function (error) {
                        console.log(`[error] ${error.message}`);
                    };

                    window.addEventListener('beforeunload', () => {
                        signalingSocket.onclose = function () { }; // disable onclose handler first
                        signalingSocket.close();
                    }, { once: true });

                } catch (ex) { console.error(ex); }
            }

            function onCreateSessionDescriptionError(error) {
                console.log(`Failed to create session description: ${error.toString()}`);
            }

            async function onCreateOfferSuccess(desc) {
                console.log(`Offer from localPeerConnection\n${desc.sdp}`);
                console.log('localPeerConnection setLocalDescription start');
                try {
                    await localPeerConnection.setLocalDescription(desc);
                    console.log(`setLocalDescription complete`);
                } catch (e) {
                    onSetSessionDescriptionError();
                }

                // send offer through signaling channel

                //console.log('pc2 setRemoteDescription start');
                //try {
                //    await pc2.setRemoteDescription(desc);
                //    onSetRemoteSuccess(pc2);
                //} catch (e) {
                //    onSetSessionDescriptionError();
                //}

                //console.log('pc2 createAnswer start');
                //// Since the 'remote' side has no media stream we need
                //// to pass in the right constraints in order for it to
                //// accept the incoming offer of audio and video.
                //try {
                //    const answer = await pc2.createAnswer();
                //    await onCreateAnswerSuccess(answer);
                //} catch (e) {
                //    onCreateSessionDescriptionError(e);
                //}
            }

            function onSetLocalSuccess(pc) {
            }

            function onSetRemoteSuccess(pc) {
                console.log(`setRemoteDescription complete`);
            }

            function onSetSessionDescriptionError(error) {
                console.log(`Failed to set session description: ${error.toString()}`);
            }

            function gotRemoteStream(e) {
                if (remoteVideo.srcObject !== e.streams[0]) {
                    remoteVideo.srcObject = e.streams[0];
                    console.log('pc2 received remote stream');
                }
            }

            async function onCreateAnswerSuccess(desc) {
                console.log(`Answer from pc2:\n${desc.sdp}`);
                console.log('pc2 setLocalDescription start');
                try {
                    await pc2.setLocalDescription(desc);
                    onSetLocalSuccess(pc2);
                } catch (e) {
                    onSetSessionDescriptionError(e);
                }
                console.log('localPeerConnection setRemoteDescription start');
                try {
                    await localPeerConnection.setRemoteDescription(desc);
                    onSetRemoteSuccess(localPeerConnection);
                } catch (e) {
                    onSetSessionDescriptionError(e);
                }
            }

            async function onIceCandidate(pc, event) {
                try {
                    await (getOtherPc(pc).addIceCandidate(event.candidate));
                    onAddIceCandidateSuccess(pc);
                } catch (e) {
                    onAddIceCandidateError(pc, e);
                }
                console.log(`ICE candidate:\n${event.candidate ? event.candidate.candidate : '(null)'}`);
            }

            function onAddIceCandidateSuccess(pc) {
                console.log(`addIceCandidate success`);
            }

            function onAddIceCandidateError(pc, error) {
                console.log(`failed to add ICE Candidate: ${error.toString()}`);
            }

            function onIceStateChange(pc, event) {
                if (pc) {
                    console.log(`ICE state: ${pc.iceConnectionState}`);
                    console.log('ICE state change event: ', event);
                }
            }



            async function videoChat_OnRemoteStream(event) {
                if (remoteVideo.srcObject !== event.streams[0]) {
                    //remoteVideo.srcObject = event.streams[0];
                    //console.log('pc2 received remote stream');
                }
            }

            var $form = document.querySelector('form');
            var $file = document.querySelector('input[type="file"]');


            var $websocketTest = document.querySelector('.websocket-test');
            var $progressValue = document.querySelector('span.progress-value');
            var $progressTotal = document.querySelector('span.progress-total');
            var $progressPercentage = document.querySelector('progress');


            var $clientWebcam = document.getElementById('client-webcam');
            var $remoteWebcams = document.getElementById('remote-webcams');
            var $getWebcamButton = document.getElementById('get-webcam-feed');
            var $startVideoChatButton = document.getElementById('start-video-chat');
            var $endVideoChatButton = document.getElementById('end-video-chat');
            var $chatSessionKey = document.getElementById('chat-session-key');


            var $chatDisplayName = document.getElementById('chat-display-name');
            var $startChat = document.getElementById('start-chat');
            var $endChat = document.getElementById('end-chat');
            var $messagingParticipants = document.getElementById('messaging-participants');
            var $messageHistory = document.getElementById('message-history');
            var $message = document.getElementById('message');
            var $sendMessageButton = document.getElementById('send-message');

            $websocketTest.addEventListener('click', websocketTest_onClick);

            $startChat.addEventListener('click', startChat_onClick);
            $endChat.addEventListener('click', endChat_onClick);
            $sendMessageButton.addEventListener('click', sendMessage_onClick);

            $getWebcamButton.addEventListener('click', getWebcam_onClick);
            $startVideoChatButton.addEventListener('click', startVideoChat_onClick);
            $endVideoChatButton.addEventListener('click', endVideoChat_onClick);
        });
    </script>
</body>
</html>